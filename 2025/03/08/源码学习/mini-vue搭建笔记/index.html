<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>mini-vue搭建笔记 | 松风狸 | Breezli</title><meta name="keywords" content="mini-vue,vue源码"><meta name="author" content="Breezli"><meta name="copyright" content="Breezli"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="mini-vue搭建笔记"><meta name="application-name" content="mini-vue搭建笔记"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="mini-vue搭建笔记"><meta property="og:url" content="http://example.com/2025/03/08/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/mini-vue%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="松风狸 | Breezli"><meta property="og:description" content="mini-vue搭建笔记原理概况1https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;cuixiaorui&amp;#x2F;mini-vue  Vue3模块组织方式流程图 简单来说处理编译 compiler-sfc专门解析sfc (使用rollup-vue把App.vue单文件组件编译成JS) compiler-dom依赖cor"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2025/03/05/67c7e99e46b9f.png"><meta property="article:author" content="Breezli"><meta property="article:tag" content="前端, 博客"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2025/03/05/67c7e99e46b9f.png"><meta name="description" content="mini-vue搭建笔记原理概况1https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;cuixiaorui&amp;#x2F;mini-vue  Vue3模块组织方式流程图 简单来说处理编译 compiler-sfc专门解析sfc (使用rollup-vue把App.vue单文件组件编译成JS) compiler-dom依赖cor"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/03/08/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/mini-vue%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css#fontawesome_animation 如果有就会加载，示例值：https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"吾身如浮萍，不敢言再会          ......","backTitle":"幸得天眷顾，得良友两三          ......"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"api","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["💻 前端技术学者","📕 红楼梦忠实书迷","🌄 旅行爱好者","🎨 国画九级选手","💤 睡觉居士","📜 诗词爱好者"]},
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Breezli","link":"链接: ","source":"来源: 松风狸 | Breezli","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '松风狸 | Breezli',
  title: 'mini-vue搭建笔记',
  postAI: '',
  pageFillDescription: 'mini-vue搭建笔记, 原理概况, Vue3模块组织方式, 流程图, 简单来说, 处理编译, 处理运行时, 更为详细的, runtime-reactivity 响应式系统, runtime-core 跨平台渲染, runtime-dom DOM方法, compiler-sfc 解析.vue组件, compiler-core 编译逻辑和算法, compiler-dom 浏览器模板编译, runtime-reactivity 响应式系统, 主流程 | 脑图, reactive 响应式设置, reactive 单测, reactive 源码实现（Proxy）, init 初始化, effect 单测, effect 源码实现, 执行fn, 触发get(访问), 执行track(收集依赖), 把effect收集起来作为依赖, update 更新, 例：effect 单测, 触发set(修改), 执行trigger(触发依赖), effect重新运行, baseHandlers | 脑图, get, set, deleteProperty, has, ownKeys, track(收集依赖) | 脑图, 初始化dep, 基于activeEffect获取当前依赖 amp dep.push(activeEffect), trigger(触发依赖) | 脑图, runtime-core 初始化核心, Demo, 渲染流程详解, mount 初始化流程, update 更新流程, 逐步搭建, 初始化项目+搭建环境, runtime-reactivity 响应式系统实现, 编写单测, effect, reactive, 实现reactive, 实现effect, 实现reactive-get, track 依赖收集, 实现reactive-set, trigger 依赖触发, 完善effect功能, 功能单测1, 功能单测2, 功能单测3, 功能单测4, 实现readonly功能, 编写单测, 实现 isReactive amp isReadonly 功能, 编写单测, 功能实现, stop功能优化, 当前bug, 代码实现, 嵌套响应式转换, 编写单测, shallowReadonly工具函数, 编写单测, 功能实现, 实现isProxy功能, 编写单测, 功能实现, 实现ref, 必看：ref与 reactive区别, 功能单测1, 功能单测2, 功能单测3, 实现isRef, 编写单测, 功能实现, 实现unRef, 编写单测, 功能实现, 实现proxyRefs (?), 编写单测, 功能实现, 实现computed, 功能单测1, 功能单测2, runtime-core 初始化流程实现, 总览导图, 初始化 component 主流程, 测试文件, 基础实现, 使用 rollup 打包库, 配置rollup, 使用, runtime-dom 封装DOM方法, compiler-core 编译逻辑和算法, compiler-sfc 解析.vue组件, compiler-dom 处理template标签搭建笔记原理概况模块组织方式流程图简单来说处理编译专门解析使用把单文件组件编译成依赖处理标签把编译转化成一个函数给提供依赖处理运行时依赖最重点的核心代码实现的响应式更为详细的响应式系统提供了诸如等来创建响应式对象或变量使用数据结构来跟踪依赖关系确保当数据变化时能够通知相关的观察者进行更新实现了函数机制用于自动追踪和触发副作用函数的执行跨平台渲染的运行时核心模块提供了跨平台的渲染能力它的主要职责包括定义了通用的渲染器接口允许开发者自定义渲染逻辑实现了组件生命周期管理插槽机制以及其他运行时所需的基础功能提供了诸如函数这样的工具用于创建虚拟节点包含了与平台无关的运行时核心实现如虚拟的渲染器组件实现和一些全局的方法模块针对浏览器环境实现了具体的运行时逻辑其主要任务是封装了一系列与操作相关的实用方法如创建元素插入节点等提供了一个基于的默认渲染器实例用于将虚拟节点渲染到真实的容器中处理特定于浏览器的行为比如属性绑定事件监听器添加等对原生属性样式事件等进行管理解析组件模块负责解析单文件组件文件它将文件中的和部分分别提取出来并对它们进行相应的处理具体而言对于部分会调用来将其编译为渲染函数对于部分可能会做一些额外的处理比如注入上下文或处理类型声明对于部分则可能涉及模块化处理或者其他样式相关的转换编译逻辑和算法作为编译的核心模块是平台无关的提供了基础的编译逻辑和算法它的职责是定义了编译的基本流程包括但不限于提供函数用于解析模板字符串到定义了方法来对进行转换实现了函数用来从生成最终的渲染函数代码提供了与平台无关的代码转换插件适用于不同类型的编译需求浏览器模板编译该模块专注于浏览器端的模板编译工作它的主要功能包括接收的模板字符串作为输入通过调用函数来执行实际的编译过程将模板字符串解析为抽象语法树对进行必要的转换和优化最终生成可执行的渲染函数代码以便在浏览器环境中运行响应式系统主流程脑图响应式设置核心创建对象类型的响应式数据修改后视图自动更新创建任意类型的响应式数据通过访问修改需使用创建依赖其他数据的计算属性和监听数据变化执行副作用变化变化单测将普通对象转换为响应式对象检查一个对象是否是响应式对象获取响应式对象对应的原始对象内部使用的数据结构用于存储原始对象和响应式对象之间的映射关系测试用例基本功能确保方法能够正确地将普通对象转换为响应式对象将普通对象转换为响应式对象确保返回的对象与原始对象不是同一个引用验证是响应式对象而不是可读取存在自有属性键名测试用例嵌套对象支持确保嵌套对象和数组也能被正确转换为响应式对象定义一个复杂对象嵌套对象数组将复杂对象转换为响应式对象测试用例方法确保可以正确地从响应式对象中获取原始对象确保通过方法可以从响应式对象中获取原始对象如果直接对原始对象调用应该返回原始对象本身源码实现原理是创建的对象目的是可以侦听到用户或者的动作先检查中是否已经存在与当前对应的代理对象存在则直接返回缓存中的代理对象避免重复创建被代理的目标对象一个拦截器对象定义了代理的行为例如如何处理和操作把创建好的给存起来另回顾功能可在用户对目标对象的访问和修改操作中自定义逻辑如触发依赖更新定义一个目标对象创建一个对象测试输出输出和初始化单测函数功能当依赖的数据发生变化时自动重新执行指定的函数函数修改状态输出输出手动停止创建一个并获取停止函数修改状态输出停止再次修改状态但不再触发无输出验证函数是否会立即执行传入的函数一次创建一个间谍函数作为参数传递给函数验证是否被调用了一次验证函数是否能够观察到响应式对象的基本属性的变化使用函数包裹一个箭头函数该函数将的值赋给验证函数是否能够观察到响应式对象的多个属性的变化验证函数是否能够处理多个响应式依赖验证函数是否能够观察到嵌套属性的变化验证函数是否能够观察到函数调用链的变化验证函数是否能够正确地调用函数验证函数是否能够正确地停止观察验证函数是否能够正确地触发事件源码实现函数用户传入的副作用函数该函数内部通常会访问响应式数据当这些响应式数据发生变化时会被重新执行一个可选的配置对象默认值为空对象将用户传入的配置对象合并到实例上但不容易直接看出实例上有哪些额外的属性调用内部方法将方法绑定到实例上创建一个新的函数当调用函数时实际上是调用方法在函数上添加一个属性指向实例执行类标记该副作用函数是否处于活跃状态存储该副作用函数的所有依赖项副作用函数停止时的回调创建对象如果为表示该副作用函数已经被停止调用了方法此时直接执行并返回结果不进行依赖收集全局变量控制是否进行依赖收集表示开始收集依赖全局变量存储当前正在执行的副作用函数表示当前正在执行的副作用函数是的实例执行用户传入的停止依赖收集当前没有正在执行的副作用函数该副作用函数已经被停止如果第一次执行后就了这是为了防止重复的调用执行逻辑从所有依赖该副作用函数的响应式对象中移除该副作用函数从而停止响应式追踪存在则调用该回调函数允许用户在副作用函数停止时执行自定义逻辑副作用函数已经停止触发访问执行收集依赖把收集起来作为依赖更新例单测触发修改验证函数是否能够观察到响应式对象的基本属性的变化更新时触发操作执行触发依赖触发后重新运行函数重新运行执行触发访问执行收集依赖把收集起来作为依赖脑图直达这些辅助函数用于检查是否为并且是否与相应的映射表或中的目标对象匹配表示对象是否为响应式对象表示对象是否为只读对象假设就是目标对象的属性值如果对象不是只读的调用函数进行依赖收集只读对象不会被修改也就不会触发函数所以不需要收集依赖在触发的时候进行依赖收集触发如果是浅响应式模式直接返回属性值不进行递归处理如果属性值是一个对象根据的值将其转换为只读响应式对象或普通响应式对象等于假设可变设置对象的属性值函数会通知所有依赖该属性的副作用函数重新执行以确保响应式系统能够正确更新相关的视图或数据设置完成返回结果收集依赖脑图初始化响应式对象即被代理的原始对象操作类型例如等不过在当前代码中参数未被使用响应式对象的属性名当前是否允许进行依赖收集触发是一个用于存储每个响应式对象对应的如果是第一次的话初始化的逻辑创建一个新的实例存储到中是一个存储每个属性对应的创建一个新的实例存储到中将当前的副作用函数添加到中并将添加到的数组中基于获取当前依赖将当前活跃的副作用函数添加到对应的依赖集合中同时将该依赖集合添加到副作用函数的依赖列表里检查是否已收集副函数添加添加依赖集合到副作用函数的依赖列表触发依赖脑图响应式对象即被代理的原始对象操作类型例如等不过在当前代码中暂时只处理了类型响应式对象的属性名存储所有依赖该属性的依赖集合从中获取对应的暂时只实现了类型类型只需要取出来就可以最后收集到内这里解构得到的是内部存储的这里的目的是只有一个这个里面包含所有的这里的目前应该是为了这个函数的复用触发该依赖集合中的所有副作用函数重新执行是中的一种数据结构类似于数组但成员的值都是唯一的没有重复的值将传入的作为初始值填充到这个中是一个存储副作用函数的集合通常是一个类型用于记录依赖于某个响应式对象属性的所有副作用函数遍历集合中的每个副作用函数存在可以让用户自己选择调用的时机这样就可以灵活的控制调用了在中就是使用了实现了在中调用的逻辑直接调用方法执行副作用函数初始化核心获取根标签节点传入根组件传入根容器一个对象标记当前组件的名字一个在组件创建之前执行的函数可使用响应式数据生命周期钩子计算属性等把转化成函数代表这个组件想要渲染出来的视图标签名属性对象数据包含了元素的子节点主页渲染流程详解初始化流程先进入获取到根容器触发函数调用内部对象的函数内部基于传来的根容器生成虚拟节点一个普通对象但有几个关键的最关键的是有对象和传入的对象是一样的调用内部的调用内部方法解构出对象判断的类型从而用不同的方法处理组件类型调用根据分成初始化更新初始化模板初始化对象把虚拟节点挂在到该对象上初始化处理组件在创建一个代理对象还是那个传来的对象将其绑定到对象上传入触发基于中的和做出一定的处理返回一个函数会把它当成函数去写返回一个对象赋值调用如果没有会将的赋值给它往回走走到使用调用该函数中要调用传来对象里的函数获取子组件生成好的虚拟节点在触发递归回去了此时已经变成元素类型了更新元素类型调用根据分成初始化更新初始化把虚拟节点转化成一个真实的元素创建真实的文本类型调用数组类型调用传入节点遍历数组触发递归此时数组元素就是类型仍然位于函数中如果元素存在遍历调用传入分类内部处理还是调用了内部的返回函数下一步调用根组件将所有的一切插回根元素组件到此所有元素就都在页面上展示出来了也就是初始化的全过程通俗来说调用就是拆箱的过程直到把内部所有的组件渲染到浏览器上更新流程样例变动一个对象标记当前组件的名字一个在组件创建之前执行的函数可使用响应式数据生命周期钩子计算属性等把转化成函数代表这个组件想要渲染出来的视图标签名属性对象数据包含了元素的子节点主页响应式的值发生改变响应式对象都在函数内执行用户传入的判断是否初始化触发当前组件的函数执行调用函数获取前后虚拟节点树节点触发前后虚拟节点树节点根据分成组件类型元素类型更新逻辑中存在进入取出新老对比对比双端对比算法实现逐步搭建初始化项目搭建环境替换把报错忽略掉配置环境根目录下创建一个文件以当前版本做一个转换支持编写测试文件单测运行响应式系统实现编写单测响应式对象收集依赖接收触发操作触发操作实现传入一个对象返回一个对象实现函数详解假设对象为收集依赖触发依赖测试实现传入一个副作用函数响应式数据发生变化时重新执行封装类将私有属性和方法封装在一起外部代码只能通过方法来执行隐藏内部实现细节提高代码的安全性和可维护性测试实现传入对象和依赖收集构建一个容器存储依赖存储依赖关系存所有依赖结构结构如何拿到全局对象类内传入实现传入对象和依赖触发测试完善功能功能单测返回可以触发创建调用调用修改逻辑实现创建实例时一次先执行一次返回函数并绑定返回值有关直接返回会让方法在调用时指向出现问题可能导致无法正常执行例子返回返回使用指向实例使用指向全局对象在浏览器中是测试功能单测通过的第二个参数给定一个的第一次执行的时候还会执行当响应式对象不会执行而是执行如果说当执行的时候会再次执行不会被调用当响应式对象时调用但不会执行调用时执行更新函数拿到可选参数拿到给类传入修改更新函数逻辑功能单测的执行逻辑停止执行实现代码修改函数定义函数并绑定将挂载到上依赖收集函数添加逻辑修改类添加函数代码优化抽离清除逻辑防抖功能单测的执行逻辑创建一个模拟函数用于记录其调用次数和参数响应式对象选项对象验证函数是否被调用了一次调用类方法调用类方法优化调用类方法抽离封装二者区别假设对象如下仅赋值属性输出输出复制对象的所有属性到输出输出继续抽离函数放置通用的工具函数修改类实现功能编写单测只读属性只能读取不能被改写返回一个新对象而非返回原对象调用了失败因为是的抽离函数返回一个函数改写函数失败因为是的继续优化抽离组件创建封装逻辑失败因为是的重构为添加缓存机制实现功能编写单测判断传入的是否为响应式对象判断是否是响应式对象判断是否是只读对象返回一个新对象而非返回原对象判断是否是只读对象功能实现拦截判断判断是否是响应式对象判断是否是只读对象判断是否是响应式对象判断是否是只读对象功能优化当前的执行逻辑停止执行只涉及操作触发会根据该响应式对象中的状态清除它的已经收集的所有依赖触发操作一定会触发操作重新收集依赖之前的依赖都白清了所以函数之后的操作不应该收集依赖不能触发操作代码实现添加逻辑如果没有激活的或者为直接返回收集依赖修改函数根据状态区分状态直接返回允许进行依赖收集执行期间访问响应式对象的属性触发依赖收集依赖收集结束后续操作不会再触发依赖收集添加逻辑嵌套响应式转换编写单测嵌套响应式对象转换返回一个新对象而非返回原对象只读只读递归拦截函数后添加判断判断是否是对象返回只读对象或者响应式对象工具函数编写单测数据展示确保外层数据不会被意外修改同时允许在必要时修改嵌套对象性能优化避免对所有嵌套对象进行只读处理表层只读内部正常功能实现改写判断前拦截判断是否是对象返回只读对象或者响应式对象继承改写自实现功能编写单测判断是否是代理对象分别添加功能实现判断是否是代理对象实现必看与区别只支持对象和数组引用数据类型支持基本数据类型引用数据类型重新分配一个新对象会丢失响应性重新分配一个新对象不会失去响应将对象传入函数时失去响应传入函数时不会失去响应能直接访问属性需要使用访问属性在和中无差别使用在和使用方式不同中要解构时会丢失响应性需使用解构对象时会丢失响应性需使用只传单值不能使用对对象起作用中的任何一个点都要对应一个进行依赖收集和触发功能单测构造函数获取功能单测执行了一次值相同不会触发值依赖就是唯一的构造函数存储值存储依赖获取回到抽离逻辑代码复用收集依赖获取设置触发依赖实现赋值相同不触发功能添加如果新值和旧值相等直接返回抽离封装成工具函数改写收集依赖获取判断是否有变化设置触发依赖功能单测嵌套响应要实现嵌套就设计递归嘛值依赖就是唯一的原始值如果是对象就递归存储依赖判断是否有变化触发依赖继续优化原始值判断是否有变化如果是对象就递归触发依赖实现编写单测功能实现标识是否是转换为布尔值实现如果参数是则返回内部值否则返回参数本身编写单测功能实现如果是就返回否则返回原对象实现编写单测可以省略可以省略功能实现逻辑到返回否则直接返回原对象实例对象触发会连锁原对象值改变如果是就返回否则返回原对象如果是就返回否则返回原对象如果是就返回否则返回原对象实现接受一个函数返回一个只读的响应式对象该通过暴露函数的返回值它也可以接受一个带有和函数的对象来创建一个可写的对象功能单测函数会基于这个函数创建一个计算属性该计算属性的值会根据的变化而自动更新功能单测接受一个函数返回一个只读的响应式对象该通过暴露函数的返回值它也可以接受一个带有和函数的对象来创建一个可写的对象再次访问不应该再调用不应该再调用触发不应该再调用初始化流程实现总览导图全程跟着这个流程图实现创建文件夹这次的测试样例放在根目录下的初始化主流程测试文件以下文件模拟创建一个根组件应用实例然后将其挂载到中从此这个里的内容由接管会根据的图纸在中渲染出你写的组件有关虚拟节点先去看看这篇文章虚拟详解含源码掘金逻辑中的创建虚拟的辅助函数用于创建虚拟节点接收三个参数要创建的标签名或组件选项对象子节点可以是字符串数字数组或其他虚拟节点组合式的入口点用于组合组件的逻辑例如响应式数据生命周期钩子计算属性等基础实现传入根组件挂载回根容器先把根组件转换成虚拟节点之后所有的操作都会基于做处理类型属性孩子对应的真实组件实例唯一标识类型标识添加函数调用函数处理处理创建组件实例对象处理组件的处理组件的组件的虚拟节点设计图组件定义比如你写的文件中的对象外部传入的属性插槽内容类似代理对象用于访问数据和属性初始化组件处理组件的先拿到组件组件定义比如你写的函数代理对象用于访问数据和属性优先从返回值中找其次从中找解构出标记当前对象是谁执行你的函数清除标记保存返回值没有直接完成初始化保存返回的对象完成组装确定函数你写的会被编译成函数准备渲染虚拟生成真实继续完善逻辑回调实现拆箱拿到虚拟节点树使用打包库一般用于库的打包而更多用于应用的打包构建输出的作用提供对不同模块格式的支持增强库的兼容性优化代码体积与性能简化库的分发与使用流程促进组件复用实现按需加载在以下案例中就构建了两种格式的文件配置安装安装官方依赖创建作为的出入口编写脚本文件入口文件输出的格式文件指定输出格式为输出的格式文件指定输出格式为插件列表构建的输出文件就是下的这两个文件在中打开依赖更改依赖项使用处理下的文件的入口再处理下的文件即可构建两种格式的文件补充函数逻辑前情提要下的文件逻辑中的创建虚拟的辅助函数用于创建虚拟节点接收三个参数要创建的标签名或组件选项对象标签属性可以是一个对象或数组子节点可以是字符串数字数组或其他虚拟节点组合式的入口点用于组合组件的逻辑例如响应式数据生命周期钩子计算属性等继续构建到测试项目里然后就可以在中直接引用构建下来的文件导入自己构建的文件然后就可以打开文件了封装方法编译逻辑和算法解析组件处理标签',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-09 14:12:00',
  postMainColor: '#41b986',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/512.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">松风狸 | Breezli</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/?id=13242559326&amp;server=netease"><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 梦境</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-plant-fill faa-tada" style="font-size: 0.9em;"></i><span> 簪花人间</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/cinema/"><i class="anzhiyufont anzhiyu-icon-book faa-tada" style="font-size: 0.9em;"></i><span> 匣中秋水</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallerygroup/"><i class="anzhiyufont anzhiyu-icon-instagram faa-tada" style="font-size: 0.9em;"></i><span> 彩云霁月</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><span> 友人</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><span> 关于</span></a></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">17</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">19</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">32</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url">源码学习</a></span><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">mini-vue搭建笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-03-08T12:28:23.274Z" title="发表于 2025-03-08 20:28:23">2025-03-08</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-03-09T06:12:00.113Z" title="更新于 2025-03-09 14:12:00">2025-03-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="mini-vue搭建笔记"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为成都"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>成都</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://bu.dusays.com/2025/03/05/67c7e99e46b9f.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/03/08/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/mini-vue%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"><header><a class="post-meta-categories" href="/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url">源码学习</a><h1 id="CrawlerTitle" itemprop="name headline">mini-vue搭建笔记</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Breezli</span><time itemprop="dateCreated datePublished" datetime="2025-03-08T12:28:23.274Z" title="发表于 2025-03-08 20:28:23">2025-03-08</time><time itemprop="dateCreated datePublished" datetime="2025-03-09T06:12:00.113Z" title="更新于 2025-03-09 14:12:00">2025-03-09</time></header><h1 id="mini-vue搭建笔记"><a href="#mini-vue搭建笔记" class="headerlink" title="mini-vue搭建笔记"></a>mini-vue搭建笔记</h1><h1 id="原理概况"><a href="#原理概况" class="headerlink" title="原理概况"></a>原理概况</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/cuixiaorui/mini-vue</span><br></pre></td></tr></table></figure>

<h2 id="Vue3模块组织方式"><a href="#Vue3模块组织方式" class="headerlink" title="Vue3模块组织方式"></a>Vue3模块组织方式</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="file:///C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20250219223855962.png?lastModify=1740547033" alt="image-20250219223855962"></p>
<h3 id="简单来说"><a href="#简单来说" class="headerlink" title="简单来说"></a>简单来说</h3><h4 id="处理编译"><a href="#处理编译" class="headerlink" title="处理编译"></a>处理编译</h4><blockquote>
<p><code>compiler-sfc</code>专门解析sfc (使用rollup-vue<em><strong>把App.vue单文件组件编译成JS</strong></em>)</p>
<p><code>compiler-dom</code>依赖core，处理template标签，<em><strong>把template编译转化成一个render函数</strong></em></p>
<p><code>compiler-core</code>给dom提供依赖</p>
</blockquote>
<h4 id="处理运行时"><a href="#处理运行时" class="headerlink" title="处理运行时"></a>处理运行时</h4><blockquote>
<p><code>runtime-dom</code>依赖core</p>
<p><code>runtime-core</code><em><strong>最重点的核心代码</strong></em></p>
<p><code>runtime-reactivity</code>实现vue的<em><strong>响应式</strong></em></p>
</blockquote>
<h3 id="更为详细的"><a href="#更为详细的" class="headerlink" title="更为详细的"></a>更为详细的</h3><h4 id="runtime-reactivity-响应式系统"><a href="#runtime-reactivity-响应式系统" class="headerlink" title="runtime-reactivity 响应式系统"></a>runtime-reactivity 响应式系统</h4><blockquote>
<p><strong>提供了诸如 reactive、ref 等 API 来创建响应式对象或变量。</strong> <strong>使用 WeakMap 数据结构来跟踪依赖关系，确保当数据变化时能够通知相关的观察者进行更新。</strong> <strong>实现了 effect 函数机制，用于自动追踪和触发副作用函数的执行。</strong></p>
</blockquote>
<h4 id="runtime-core-跨平台渲染"><a href="#runtime-core-跨平台渲染" class="headerlink" title="runtime-core 跨平台渲染"></a>runtime-core 跨平台渲染</h4><blockquote>
<p><strong>Vue3 的运行时核心模块，提供了跨平台的渲染能力。它的主要职责包括：</strong> <strong>定义了通用的渲染器接口 createRenderer，允许开发者自定义渲染逻辑。</strong> <strong>实现了组件生命周期管理、插槽机制以及其他运行时所需的基础功能。</strong> <strong>提供了诸如 h 函数这样的工具，用于创建虚拟 DOM 节点。</strong> <strong>包含了与平台无关的运行时核心实现（如虚拟 DOM 的渲染器、组件实现和一些全局的 JS API）。</strong></p>
</blockquote>
<h4 id="runtime-dom-DOM方法"><a href="#runtime-dom-DOM方法" class="headerlink" title="runtime-dom DOM方法"></a>runtime-dom DOM方法</h4><blockquote>
<p><strong>runtime-dom 模块针对浏览器环境实现了具体的运行时逻辑。其主要任务是：</strong> <strong>封装了一系列与 DOM 操作相关的实用方法，如创建元素、插入节点等。</strong> <strong>提供了一个基于 runtime-core 的默认渲染器实例，用于将虚拟 DOM 节点渲染到真实的 DOM 容器中。</strong> <strong>处理特定于浏览器的行为，比如属性绑定、事件监听器添加等。</strong> <strong>对原生 DOM API、属性、样式、事件等进行管理。</strong></p>
</blockquote>
<h4 id="compiler-sfc-解析-vue组件"><a href="#compiler-sfc-解析-vue组件" class="headerlink" title="compiler-sfc 解析.vue组件"></a>compiler-sfc 解析.vue组件</h4><blockquote>
<p><strong>compiler-sfc 模块负责解析单文件组件（.vue 文件），它将 .vue 文件中的 <strong><template></strong>、</strong><script>** 和 <strong><style></strong> 部分分别提取出来，并对它们进行相应的处理。具体而言：** <strong>对于 <strong><template></strong> 部分，会调用 compiler-dom 来将其编译为渲染函数。</strong> <strong>对于 <strong><script></strong> 部分，可能会做一些额外的处理，比如注入上下文或处理 TypeScript 类型声明。</strong> <strong>对于 <strong><style></strong> 部分，则可能涉及 CSS 模块化处理或者其他样式相关的转换。</strong></p>
</blockquote>
<h4 id="compiler-core-编译逻辑和算法"><a href="#compiler-core-编译逻辑和算法" class="headerlink" title="compiler-core 编译逻辑和算法"></a>compiler-core 编译逻辑和算法</h4><blockquote>
<p><strong>作为 Vue 编译的核心模块，compiler-core 是平台无关的，提供了基础的编译逻辑和算法。它的职责是定义了编译的基本流程，包括但不限于：</strong> <strong>提供 baseParse 函数用于解析模板字符串到 AST。</strong> <strong>定义了 transform 方法来对 AST 进行转换。</strong> <strong>实现了 generate 函数用来从 AST 生成最终的渲染函数代码。</strong> <strong>提供了与平台无关的代码转换插件，适用于不同类型的编译需求。</strong></p>
</blockquote>
<h4 id="compiler-dom-浏览器模板编译"><a href="#compiler-dom-浏览器模板编译" class="headerlink" title="compiler-dom 浏览器模板编译"></a>compiler-dom 浏览器模板编译</h4><blockquote>
<p><strong>该模块专注于浏览器端的模板编译工作。它的主要功能包括：</strong> <strong>接收 Vue 的模板字符串作为输入，通过调用 baseCompile 函数来执行实际的编译过程。</strong> <strong>将模板字符串解析为抽象语法树（AST）。</strong> <strong>对 AST 进行必要的转换和优化。</strong> <strong>最终生成可执行的 JavaScript 渲染函数代码，以便在浏览器环境中运行。</strong></p>
</blockquote>
<h1 id="runtime-reactivity-响应式系统-1"><a href="#runtime-reactivity-响应式系统-1" class="headerlink" title="runtime-reactivity 响应式系统"></a>runtime-reactivity 响应式系统</h1><h2 id="主流程-脑图"><a href="#主流程-脑图" class="headerlink" title="主流程 | 脑图"></a>主流程 | 脑图</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="file:///C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20250220163321605.png?lastModify=1740547033" alt="image-20250220163321605"></p>
<h3 id="reactive-响应式设置"><a href="#reactive-响应式设置" class="headerlink" title="reactive 响应式设置"></a>reactive 响应式设置</h3><blockquote>
<p><em><strong>reactivity核心API</strong></em></p>
<p><strong><code>reactive()</code><strong>创建</strong>对象类型</strong>的响应式数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line">const state = reactive(&#123; count: 0 &#125;);</span><br><span class="line">state.count++; // 修改后视图自动更新</span><br></pre></td></tr></table></figure>

<p><strong><code>ref()</code><strong>创建</strong>任意类型</strong>的响应式数据（通过 <code>.value</code> 访问）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">const num = ref(0);</span><br><span class="line">num.value = 10; // 修改需使用 .value</span><br></pre></td></tr></table></figure>

<p>**<code>computed()</code>**创建依赖其他数据的计算属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const doubleCount = computed(() =&gt; state.count * 2);</span><br></pre></td></tr></table></figure>

<p>**<code>watch()</code> 和 <code>watchEffect()</code>**监听数据变化执行副作用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch(num, (newVal) =&gt; console.log(&#x27;num变化:&#x27;, newVal));</span><br><span class="line">watchEffect(() =&gt; console.log(&#x27;count变化:&#x27;, state.count));</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="reactive-单测"><a href="#reactive-单测" class="headerlink" title="reactive 单测"></a>reactive 单测</h4><p><strong>reactivity / tests / reactive.spec.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive, isReactive, toRaw, reactiveMap &#125; from &quot;../src/reactive&quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>reactive</code>: 将普通对象转换为响应式对象。** <strong><code>isReactive</code>: 检查一个对象是否是响应式对象。</strong> <strong><code>toRaw</code>: 获取响应式对象对应的原始对象。</strong> **<code>reactiveMap</code>: 内部使用的 Map 数据结构，用于存储原始对象和响应式对象之间的映射关系。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">describe(&quot;reactive&quot;, () =&gt; &#123;</span><br><span class="line">  test(&quot;Object&quot;, () =&gt; &#123;//测试用例1 | 基本功能：确保 reactive 方法能够正确地将普通对象转换为响应式对象。</span><br><span class="line">    const original = &#123; foo: 1 &#125;;</span><br><span class="line">    const observed = reactive(original);//将普通对象转换为响应式对象</span><br><span class="line">    expect(observed).not.toBe(original);//确保 reactive 返回的对象与原始对象不是同一个引用</span><br><span class="line">    expect(isReactive(observed)).toBe(true);//验证 observed 是响应式对象</span><br><span class="line">    expect(isReactive(original)).toBe(false);//而 original 不是</span><br><span class="line">    expect(observed.foo).toBe(1);//可读取</span><br><span class="line">    expect(&quot;foo&quot; in observed).toBe(true);//存在</span><br><span class="line">    expect(Object.keys(observed)).toEqual([&quot;foo&quot;]);//自有属性键名</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(&quot;nested reactives&quot;, () =&gt; &#123;//测试用例2 | 嵌套对象支持：确保嵌套对象和数组也能被正确转换为响应式对象。</span><br><span class="line">    const original = &#123;//定义一个复杂对象</span><br><span class="line">      nested: &#123;//嵌套对象</span><br><span class="line">        foo: 1,</span><br><span class="line">      &#125;,</span><br><span class="line">      array: [&#123; bar: 2 &#125;],//数组</span><br><span class="line">    &#125;;</span><br><span class="line">    const observed = reactive(original);//将复杂对象转换为响应式对象</span><br><span class="line">    expect(isReactive(observed.nested)).toBe(true);</span><br><span class="line">    expect(isReactive(observed.array)).toBe(true);</span><br><span class="line">    expect(isReactive(observed.array[0])).toBe(true);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(&quot;toRaw&quot;, () =&gt; &#123;//测试用例3 | toRaw 方法：确保可以正确地从响应式对象中获取原始对象。</span><br><span class="line">    const original = &#123; foo: 1 &#125;;</span><br><span class="line">    const observed = reactive(original);</span><br><span class="line">    expect(toRaw(observed)).toBe(original);//确保通过 toRaw 方法可以从响应式对象 observed 中获取原始对象 original</span><br><span class="line">    expect(toRaw(original)).toBe(original);//如果直接对原始对象调用 toRaw，应该返回原始对象本身</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="reactive-源码实现（Proxy）"><a href="#reactive-源码实现（Proxy）" class="headerlink" title="reactive 源码实现（Proxy）"></a>reactive 源码实现（<em>Proxy</em>）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function reactive(target) &#123;</span><br><span class="line">  return createReactiveObject(target, reactiveMap, mutableHandlers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>👇</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createReactiveObject(target, proxyMap, baseHandlers) &#123;//原理是JS创建的Proxy对象，目的是可以侦听到用户 get 或者 set 的动作</span><br><span class="line">    </span><br><span class="line">  const existingProxy = proxyMap.get(target);//先检查 proxyMap 中是否已经存在与当前 target 对应的代理对象。</span><br><span class="line">  if (existingProxy) &#123;//存在则直接返回缓存中的代理对象，避免重复创建。</span><br><span class="line">    return existingProxy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //target 被代理的目标对象</span><br><span class="line">  //baseHandlers 一个拦截器对象，定义了代理的行为（例如如何处理 get 和 set 操作）</span><br><span class="line">  const proxy = new Proxy(target, baseHandlers);</span><br><span class="line"></span><br><span class="line">  proxyMap.set(target, proxy);//把创建好的 proxy 给存起来</span><br><span class="line">  return proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>另：回顾Proxy功能 | 可在用户对目标对象的</strong>***访问(get)<em><strong>和</strong></em>修改(set)***操作中，自定义逻辑（如触发依赖更新）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个目标对象</span><br><span class="line">const target = &#123; count: 0 &#125;;</span><br><span class="line"></span><br><span class="line">// 创建一个 Proxy 对象</span><br><span class="line">const reactiveObj = new Proxy(target, &#123;</span><br><span class="line">get(target, key, receiver) &#123;</span><br><span class="line">console.log(`Getting $&#123;key&#125;`);</span><br><span class="line">return Reflect.get(target, key, receiver);</span><br><span class="line">&#125;,</span><br><span class="line">set(target, key, value, receiver) &#123;</span><br><span class="line">console.log(`Setting $&#123;key&#125; to $&#123;value&#125;`);</span><br><span class="line">const result = Reflect.set(target, key, value, receiver);</span><br><span class="line">if (result) &#123;</span><br><span class="line">console.log(&quot;Trigger updates...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">console.log(reactiveObj.count); // 输出: Getting count</span><br><span class="line">reactiveObj.count++; // 输出: Setting count to 1 和 Trigger updates...</span><br></pre></td></tr></table></figure></blockquote>
<h3 id="init-初始化"><a href="#init-初始化" class="headerlink" title="init 初始化"></a>init 初始化</h3><h4 id="effect-单测"><a href="#effect-单测" class="headerlink" title="effect 单测"></a>effect 单测</h4><blockquote>
<p><em><strong>effect 函数功能</strong></em></p>
<p><strong>当依赖的数据发生变化时，自动重新执行指定的函数。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive, effect &#125; from &#x27;@vue/reactivity&#x27;;</span><br><span class="line"></span><br><span class="line">const state = reactive(&#123; count: 0 &#125;);</span><br><span class="line"></span><br><span class="line">// effect函数</span><br><span class="line">effect(() =&gt; &#123;</span><br><span class="line">console.log(`Count is $&#123;state.count&#125;`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 修改状态</span><br><span class="line">state.count++; // 输出: Count is 1</span><br><span class="line">state.count++; // 输出: Count is 2</span><br></pre></td></tr></table></figure>

<p>**手动停止 **<code>effect</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 effect 并获取停止函数</span><br><span class="line">const stop = effect(() =&gt; &#123;</span><br><span class="line">console.log(`Count is $&#123;state.count&#125;`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 修改状态</span><br><span class="line">state.count++; // 输出: Count is 1</span><br><span class="line">// 停止 effect</span><br><span class="line">stop();</span><br><span class="line">// 再次修改状态，但 effect 不再触发</span><br><span class="line">state.count++; // 无输出</span><br></pre></td></tr></table></figure></blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive &#125; from &quot;../src/reactive&quot;;</span><br><span class="line">import &#123; effect, stop &#125; from &quot;../src/effect&quot;;</span><br><span class="line">import &#123; vi &#125; from &quot;vitest&quot;;</span><br><span class="line"></span><br><span class="line">describe(&quot;effect&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;should run the passed function once (wrapped by a effect)&quot;, () =&gt; &#123; //验证 effect 函数是否会立即执行传入的函数一次</span><br><span class="line">    const fnSpy = vi.fn(() =&gt; &#123;&#125;);//创建一个间谍函数fnSpy</span><br><span class="line">    effect(fnSpy);//fnSpy作为参数传递给effect函数</span><br><span class="line">    expect(fnSpy).toHaveBeenCalledTimes(1);//验证fnSpy是否被调用了一次</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;should observe basic properties&quot;, () =&gt; &#123;//验证 effect 函数是否能够观察到响应式对象的基本属性的变化</span><br><span class="line">    let dummy;</span><br><span class="line">    const counter = reactive(&#123; num: 0 &#125;);</span><br><span class="line">    effect(() =&gt; (dummy = counter.num));//使用 effect 函数包裹一个箭头函数，该函数将 counter.num 的值赋给 dummy。</span><br><span class="line">    </span><br><span class="line">    expect(dummy).toBe(0);</span><br><span class="line">    counter.num = 7;</span><br><span class="line">    expect(dummy).toBe(7);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;should observe multiple properties&quot;, () =&gt; &#123;//验证 effect 函数是否能够观察到响应式对象的多个属性的变化</span><br><span class="line">    let dummy;</span><br><span class="line">    const counter = reactive(&#123; num1: 0, num2: 0 &#125;);</span><br><span class="line">    effect(() =&gt; (dummy = counter.num1 + counter.num1 + counter.num2));</span><br><span class="line">    </span><br><span class="line">    expect(dummy).toBe(0);</span><br><span class="line">    counter.num1 = counter.num2 = 7;</span><br><span class="line">    expect(dummy).toBe(21);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;should handle multiple effects&quot;, () =&gt; &#123;//验证 effect 函数是否能够处理多个响应式依赖</span><br><span class="line">    let dummy1, dummy2;</span><br><span class="line">    const counter = reactive(&#123; num: 0 &#125;);</span><br><span class="line">    effect(() =&gt; (dummy1 = counter.num));</span><br><span class="line">    effect(() =&gt; (dummy2 = counter.num));</span><br><span class="line"></span><br><span class="line">    expect(dummy1).toBe(0);</span><br><span class="line">    expect(dummy2).toBe(0);</span><br><span class="line">    counter.num++;</span><br><span class="line">    expect(dummy1).toBe(1);</span><br><span class="line">    expect(dummy2).toBe(1);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;should observe nested properties&quot;, () =&gt; &#123;//验证 effect 函数是否能够观察到嵌套属性的变化</span><br><span class="line">    let dummy;</span><br><span class="line">    const counter = reactive(&#123; nested: &#123; num: 0 &#125; &#125;);</span><br><span class="line">    effect(() =&gt; (dummy = counter.nested.num));</span><br><span class="line"></span><br><span class="line">    expect(dummy).toBe(0);</span><br><span class="line">    counter.nested.num = 8;</span><br><span class="line">    expect(dummy).toBe(8);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;should observe function call chains&quot;, () =&gt; &#123;//验证 effect 函数是否能够观察到函数调用链的变化</span><br><span class="line">    let dummy;</span><br><span class="line">    const counter = reactive(&#123; num: 0 &#125;);</span><br><span class="line">    effect(() =&gt; (dummy = getNum()));</span><br><span class="line"></span><br><span class="line">    function getNum() &#123;</span><br><span class="line">      return counter.num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    expect(dummy).toBe(0);</span><br><span class="line">    counter.num = 2;</span><br><span class="line">    expect(dummy).toBe(2);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;scheduler&quot;, () =&gt; &#123;//验证 effect 函数是否能够正确地调用 scheduler 函数</span><br><span class="line">    let dummy;</span><br><span class="line">    let run: any;</span><br><span class="line">    const scheduler = vi.fn(() =&gt; &#123;</span><br><span class="line">      run = runner;</span><br><span class="line">    &#125;);</span><br><span class="line">    const obj = reactive(&#123; foo: 1 &#125;);</span><br><span class="line">    const runner = effect(</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        dummy = obj.foo;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; scheduler &#125;</span><br><span class="line">    );</span><br><span class="line">    expect(scheduler).not.toHaveBeenCalled();</span><br><span class="line">    expect(dummy).toBe(1);</span><br><span class="line">    // should be called on first trigger</span><br><span class="line">    obj.foo++;</span><br><span class="line">    expect(scheduler).toHaveBeenCalledTimes(1);</span><br><span class="line">    // // should not run yet</span><br><span class="line">    expect(dummy).toBe(1);</span><br><span class="line">    // // manually run</span><br><span class="line">    run();</span><br><span class="line">    // // should have run</span><br><span class="line">    expect(dummy).toBe(2);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;stop&quot;, () =&gt; &#123;//验证 effect 函数是否能够正确地停止观察</span><br><span class="line">    let dummy;</span><br><span class="line">    const obj = reactive(&#123; prop: 1 &#125;);</span><br><span class="line">    const runner = effect(() =&gt; &#123;</span><br><span class="line">      dummy = obj.prop;</span><br><span class="line">    &#125;);</span><br><span class="line">    obj.prop = 2;</span><br><span class="line">    expect(dummy).toBe(2);</span><br><span class="line">    stop(runner);</span><br><span class="line">    // obj.prop = 3</span><br><span class="line">    obj.prop++;</span><br><span class="line">    expect(dummy).toBe(2);</span><br><span class="line"></span><br><span class="line">    // stopped effect should still be manually callable</span><br><span class="line">    runner();</span><br><span class="line">    expect(dummy).toBe(3);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;events: onStop&quot;, () =&gt; &#123;//验证 effect 函数是否能够正确地触发 onStop 事件</span><br><span class="line">    const onStop = vi.fn();</span><br><span class="line">    const runner = effect(() =&gt; &#123;&#125;, &#123;</span><br><span class="line">      onStop,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    stop(runner);</span><br><span class="line">    expect(onStop).toHaveBeenCalled();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="effect-源码实现"><a href="#effect-源码实现" class="headerlink" title="effect 源码实现"></a>effect 源码实现</h4><p><strong>effect函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export function effect(fn, options = &#123;&#125;) &#123;</span><br><span class="line">    //fn：用户传入的副作用函数，该函数内部通常会访问响应式数据，当这些响应式数据发生变化时，fn 会被重新执行。</span><br><span class="line">    //options：一个可选的配置对象，默认值为空对象 &#123;&#125;。</span><br><span class="line">    const _effect = new ReactiveEffect(fn);</span><br><span class="line"></span><br><span class="line">    extend(_effect, options);//将用户传入的 options 配置对象合并到_effect 实例上，但不容易直接看出 _effect 实例上有哪些额外的属性</span><br><span class="line">    _effect.run();//调用内部run方法</span><br><span class="line"></span><br><span class="line">    // 将 _effect.run 方法绑定到 _effect 实例上，创建一个新的函数 runner</span><br><span class="line">    // 当调用 runner 函数时，实际上是调用 _effect.run 方法</span><br><span class="line">    const runner: any = _effect.run.bind(_effect);</span><br><span class="line">    //在 runner 函数上添加一个 effect 属性，指向 _effect 实例</span><br><span class="line">    runner.effect = _effect;</span><br><span class="line">    return runner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行fn"><a href="#执行fn" class="headerlink" title="执行fn"></a>执行fn</h5><p><strong>ReactiveEffect类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">export class ReactiveEffect &#123;</span><br><span class="line">  active = true; //标记该副作用函数是否处于活跃状态</span><br><span class="line">  deps = []; //存储该副作用函数的所有依赖项</span><br><span class="line">  public onStop?: () =&gt; void; //副作用函数停止时的回调</span><br><span class="line">  constructor(public fn, public scheduler?) &#123;</span><br><span class="line">    console.log(&quot;创建 ReactiveEffect 对象&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    console.log(&quot;run&quot;);</span><br><span class="line">      </span><br><span class="line">    //如果 this.active 为 false，表示该副作用函数已经被停止（调用了 stop 方法），此时直接执行 this.fn() 并返回结果，不进行依赖收集。</span><br><span class="line">    if (!this.active) &#123;</span><br><span class="line">      return this.fn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shouldTrack = true;//全局变量，控制是否进行依赖收集。true表示开始收集依赖。</span><br><span class="line">    activeEffect = this as any;//全局变量，存储当前正在执行的副作用函数。this表示当前正在执行的副作用函数是 ReactiveEffect 的实例。</span><br><span class="line">      </span><br><span class="line">    console.log(&quot;执行用户传入的 fn&quot;);</span><br><span class="line">    const result = this.fn();</span><br><span class="line"></span><br><span class="line">    shouldTrack = false;//停止依赖收集。</span><br><span class="line">    activeEffect = undefined;//当前没有正在执行的副作用函数。</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop() &#123;</span><br><span class="line">    if (this.active) &#123;//该副作用函数已经被停止</span><br><span class="line">      // 如果第一次执行 stop 后 active 就 false 了，这是为了防止重复的调用，执行 stop 逻辑</span><br><span class="line">      cleanupEffect(this);//从所有依赖该副作用函数的响应式对象中移除该副作用函数，从而停止响应式追踪</span><br><span class="line">      if (this.onStop) &#123;//this.onStop 存在，则调用该回调函数，允许用户在副作用函数停止时执行自定义逻辑</span><br><span class="line">        this.onStop();</span><br><span class="line">      &#125;</span><br><span class="line">      this.active = false;//副作用函数已经停止</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="触发get-访问"><a href="#触发get-访问" class="headerlink" title="触发get(访问)"></a>触发get(访问)</h5><h5 id="执行track-收集依赖"><a href="#执行track-收集依赖" class="headerlink" title="执行track(收集依赖)"></a>执行track(收集依赖)</h5><h5 id="把effect收集起来作为依赖"><a href="#把effect收集起来作为依赖" class="headerlink" title="把effect收集起来作为依赖"></a>把effect收集起来作为依赖</h5><h3 id="update-更新"><a href="#update-更新" class="headerlink" title="update 更新"></a>update 更新</h3><h4 id="例：effect-单测"><a href="#例：effect-单测" class="headerlink" title="例：effect 单测"></a>例：effect 单测</h4><h5 id="触发set-修改"><a href="#触发set-修改" class="headerlink" title="触发set(修改)"></a>触发set(修改)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it(&quot;should observe basic properties&quot;, () =&gt; &#123;//验证 effect 函数是否能够观察到响应式对象的基本属性的变化</span><br><span class="line">    let dummy;</span><br><span class="line">    const counter = reactive(&#123; num: 0 &#125;);</span><br><span class="line">    effect(() =&gt; (dummy = counter.num));</span><br><span class="line"></span><br><span class="line">    expect(dummy).toBe(0);</span><br><span class="line">    counter.num = 7;// 更新时触发set操作</span><br><span class="line">    expect(dummy).toBe(7);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="执行trigger-触发依赖"><a href="#执行trigger-触发依赖" class="headerlink" title="执行trigger(触发依赖)"></a>执行trigger(触发依赖)</h5><p><strong>baseHandlers.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createSetter() &#123;</span><br><span class="line">    return function set(target, key, value, receiver) &#123;</span><br><span class="line">        const result = Reflect.set(target, key, value, receiver)</span><br><span class="line"></span><br><span class="line">        trigger(target, &#x27;set&#x27;, key)// 触发trigger后重新运行effect函数</span><br><span class="line"></span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="effect重新运行"><a href="#effect重新运行" class="headerlink" title="effect重新运行"></a>effect重新运行</h5><blockquote>
<p><strong>执行fn-&gt;触发get(访问)-&gt;执行track(收集依赖)-&gt;把effect收集起来作为依赖</strong></p>
</blockquote>
<h2 id="baseHandlers-脑图"><a href="#baseHandlers-脑图" class="headerlink" title="baseHandlers | 脑图"></a>baseHandlers | 脑图</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="file:///C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20250220164149032.png?lastModify=1740547033" alt="image-20250220164149032"></p>
<p><strong>直达src / baseHandlers.ts</strong></p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">function createGetter(isReadonly = false, shallow = false) &#123;</span><br><span class="line">  return function get(target, key, receiver) &#123;</span><br><span class="line">    //这些辅助函数用于检查 key 是否为 ReactiveFlags.RAW，并且 receiver 是否与相应的映射表（reactiveMap、readonlyMap 或 shallowReadonlyMap）中的目标对象匹配。</span><br><span class="line">    const isExistInReactiveMap = () =&gt;</span><br><span class="line">      key === ReactiveFlags.RAW &amp;&amp; receiver === reactiveMap.get(target);</span><br><span class="line"></span><br><span class="line">    const isExistInReadonlyMap = () =&gt;</span><br><span class="line">      key === ReactiveFlags.RAW &amp;&amp; receiver === readonlyMap.get(target);</span><br><span class="line"></span><br><span class="line">    const isExistInShallowReadonlyMap = () =&gt;</span><br><span class="line">      key === ReactiveFlags.RAW &amp;&amp; receiver === shallowReadonlyMap.get(target);</span><br><span class="line"></span><br><span class="line">    if (key === ReactiveFlags.IS_REACTIVE) &#123;//表示对象是否为响应式对象。</span><br><span class="line">      return !isReadonly;</span><br><span class="line">    &#125; else if (key === ReactiveFlags.IS_READONLY) &#123;</span><br><span class="line">      return isReadonly;</span><br><span class="line">    &#125; else if (//表示对象是否为只读对象。</span><br><span class="line">      isExistInReactiveMap() ||</span><br><span class="line">      isExistInReadonlyMap() ||</span><br><span class="line">      isExistInShallowReadonlyMap()</span><br><span class="line">    ) &#123;</span><br><span class="line">      return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //假设obj=&#123;foo:1&#125; key:foo -&gt; res = 1 res就是目标对象的属性值//</span><br><span class="line">    const res = Reflect.get(target, key, receiver);</span><br><span class="line"></span><br><span class="line">    if (!isReadonly) &#123;//如果对象不是只读的，调用 track 函数进行依赖收集。只读对象不会被修改，也就不会触发 trigger 函数，所以不需要收集依赖。</span><br><span class="line">      // 在触发 get 的时候进行依赖收集</span><br><span class="line">      track(target, &quot;get&quot;, key);//触发track</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (shallow) &#123;//如果是浅响应式模式，直接返回属性值，不进行递归处理</span><br><span class="line">      return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isObject(res)) &#123;//如果属性值是一个对象，根据 isReadonly 的值，将其转换为只读响应式对象或普通响应式对象</span><br><span class="line">      // res 等于 target[key]</span><br><span class="line">      return isReadonly ? readonly(res) : reactive(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createSetter() &#123;</span><br><span class="line">    return function set(target, key, value, receiver) &#123;</span><br><span class="line">         //假设obj=&#123;foo:1&#125; key:foo -&gt; value可变2//</span><br><span class="line">         //obj=&#123;foo:2&#125;//</span><br><span class="line">        const result = Reflect.set(target, key, value, receiver)//设置对象的属性值</span><br><span class="line"></span><br><span class="line">        trigger(target, &#x27;set&#x27;, key)//trigger函数会通知所有依赖该属性的副作用函数重新执行，以确保响应式系统能够正确更新相关的视图或数据。</span><br><span class="line"></span><br><span class="line">        return result//设置完成，返回结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty"></a>deleteProperty</h3><h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h3><h2 id="track-收集依赖-脑图"><a href="#track-收集依赖-脑图" class="headerlink" title="track(收集依赖) | 脑图"></a>track(收集依赖) | 脑图</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="file:///C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20250220212111915.png?lastModify=1740547033" alt="image-20250220212111915"></p>
<h3 id="初始化dep"><a href="#初始化dep" class="headerlink" title="初始化dep"></a>初始化dep</h3><p><strong>src / effect.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export function track(target, type, key) &#123;</span><br><span class="line">    //target：响应式对象，即被代理的原始对象。</span><br><span class="line">    //type：操作类型，例如 GET、SET 等，不过在当前代码中，type 参数未被使用。</span><br><span class="line">    //key：响应式对象的属性名。</span><br><span class="line">    if (!isTracking()) &#123;//当前是否允许进行依赖收集</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(`触发 track -&gt; target: $&#123;target&#125; type:$&#123;type&#125; key:$&#123;key&#125;`);</span><br><span class="line">    </span><br><span class="line">    let depsMap = targetMap.get(target);//targetMap 是一个 WeakMap，用于存储每个响应式对象对应的 depsMap</span><br><span class="line">    if (!depsMap) &#123;// 如果是第一次的话，初始化 depsMap 的逻辑</span><br><span class="line">        depsMap = new Map();// 创建一个新的 Map 实例</span><br><span class="line">        targetMap.set(target, depsMap);//存储到 targetMap 中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let dep = depsMap.get(key);//depsMap 是一个 Map，存储每个属性对应的 dep</span><br><span class="line">    if (!dep) &#123;</span><br><span class="line">        dep = createDep();//创建一个新的 dep 实例</span><br><span class="line">        depsMap.set(key, dep);//存储到 depsMap 中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trackEffects(dep);//将当前的副作用函数（activeEffect）添加到 dep 中，并将 dep 添加到 activeEffect 的 deps 数组中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于activeEffect获取当前依赖-dep-push-activeEffect"><a href="#基于activeEffect获取当前依赖-dep-push-activeEffect" class="headerlink" title="基于activeEffect获取当前依赖 &amp; dep.push(activeEffect)"></a>基于activeEffect获取当前依赖 &amp; dep.push(activeEffect)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export function trackEffects(dep) &#123;</span><br><span class="line">    // 将当前活跃的副作用函数（activeEffect）添加到对应的依赖集合（dep）中，同时将该依赖集合添加到副作用函数的依赖列表（deps）里。</span><br><span class="line">    if (!dep.has(activeEffect)) &#123;//检查是否已收集副函数</span><br><span class="line">        dep.add(activeEffect);//添加</span><br><span class="line">        (activeEffect as any).deps.push(dep);//添加依赖集合到副作用函数的依赖列表</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="trigger-触发依赖-脑图"><a href="#trigger-触发依赖-脑图" class="headerlink" title="trigger(触发依赖) | 脑图"></a>trigger(触发依赖) | 脑图</h2><p><strong>src / effect.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export function trigger(target, type, key) &#123;</span><br><span class="line">    // target：响应式对象，即被代理的原始对象。</span><br><span class="line">    // type：操作类型，例如 GET、SET 等。不过在当前代码中，暂时只处理了 GET 类型。</span><br><span class="line">    // key：响应式对象的属性名。</span><br><span class="line">    let deps: Array&lt;any&gt; = [];//存储所有依赖该属性的依赖集合（dep）</span><br><span class="line"></span><br><span class="line">    const depsMap = targetMap.get(target);//从 targetMap 中获取 target 对应的 depsMap</span><br><span class="line"></span><br><span class="line">    if (!depsMap) return;</span><br><span class="line"></span><br><span class="line">    // 暂时只实现了 GET 类型</span><br><span class="line">    // get 类型只需要取出来就可以</span><br><span class="line">    const dep = depsMap.get(key);</span><br><span class="line"></span><br><span class="line">    deps.push(dep);// 最后收集到 deps 内</span><br><span class="line"></span><br><span class="line">    const effects: Array&lt;any&gt; = [];</span><br><span class="line">    deps.forEach((dep) =&gt; &#123; // 这里解构 dep 得到的是 dep 内部存储的 effect</span><br><span class="line">        effects.push(...dep);</span><br><span class="line">    &#125;);</span><br><span class="line">    // 这里的目的是只有一个 dep ，这个dep 里面包含所有的 effect</span><br><span class="line">    // 这里的目前应该是为了 triggerEffects 这个函数的复用</span><br><span class="line">    triggerEffects(createDep(effects));// 触发该依赖集合中的所有副作用函数重新执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>src / dep.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export function createDep(effects?) &#123;</span><br><span class="line">    // Set 是 JavaScript 中的一种数据结构，类似于数组，但成员的值都是唯一的，没有重复的值。</span><br><span class="line">    const dep = new Set(effects);// 将传入的 effects 作为初始值填充到这个 Set 中</span><br><span class="line">    return dep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>src / effect.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export function triggerEffects(dep) &#123; // dep 是一个存储副作用函数的集合，通常是一个 Set 类型，用于记录依赖于某个响应式对象属性的所有副作用函数。</span><br><span class="line">    for (const effect of dep) &#123;// 遍历 dep 集合中的每个副作用函数 effect</span><br><span class="line">        if (effect.scheduler) &#123;// effect.scheduler存在</span><br><span class="line">            // scheduler 可以让用户自己选择调用的时机，这样就可以灵活的控制调用了</span><br><span class="line">            // 在 runtime-core 中，就是使用了 scheduler 实现了在 next ticker 中调用的逻辑</span><br><span class="line">            effect.scheduler();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            effect.run();// 直接调用 effect.run() 方法，执行副作用函数。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="runtime-core-初始化核心"><a href="#runtime-core-初始化核心" class="headerlink" title="runtime-core 初始化核心"></a>runtime-core 初始化核心</h1><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><strong>example / helloWorld</strong></p>
<p><strong>index.html</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;main.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>main.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &quot;../../dist/mini-vue.esm-bundler.js&quot;;</span><br><span class="line">import App from &quot;./App.js&quot;;</span><br><span class="line"></span><br><span class="line">const rootContainer = document.querySelector(&quot;#root&quot;);//获取根标签节点</span><br><span class="line">createApp(App).mount(rootContainer); //createApp(传入根组件).mount(传入根容器)</span><br></pre></td></tr></table></figure>

<p><strong>App.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;//一个对象</span><br><span class="line">    name: &quot;App&quot;,//标记当前组件的名字</span><br><span class="line">    setup(props,context) &#123;&#125;,//一个在组件创建之前执行的函数，可使用响应式数据、生命周期钩子、计算属性等</span><br><span class="line"></span><br><span class="line">    render() &#123;//把template转化成render函数，代表这个组件想要渲染出来的视图</span><br><span class="line">        //tag标签名(div)  props属性对象  children数据包含了(div 元素的子节点)</span><br><span class="line">        return h(&quot;div&quot;, &#123; tId: 1 &#125;, [h(&quot;p&quot;, &#123;&#125;, &quot;主页&quot;), h(HelloWorld)]);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="渲染流程详解"><a href="#渲染流程详解" class="headerlink" title="渲染流程详解"></a>渲染流程详解</h2><h3 id="mount-初始化流程"><a href="#mount-初始化流程" class="headerlink" title="mount 初始化流程"></a>mount 初始化流程</h3><blockquote>
<p><strong>先进入main.js---获取到根容器---触发createApp函数---调用createApp内部App对象的mount函数---mount内部基于传来的根容器生成虚拟节点vnode(一个普通对象但有几个关键的key，最关键的是有type对象[和传入的对象是一样的name|setup|render])</strong></p>
<p><strong>调用mount内部的render---调用内部patch方法---解构出type对象---switch判断type的类型从而用不同的方法处理</strong></p>
<blockquote>
<p><strong>component</strong> 组件类型---调用processComponent---根据!n1分成初始化or更新</p>
</blockquote>
<blockquote>
<blockquote>
<p><strong>mountComponent</strong> 初始化---模板初始化对象+把vnode虚拟节点挂在到该对象上---<em><strong>setupComponent</strong></em>---initProps+initSlots+setupStatefulComponent初始化props/slots/setup&amp;处理组件---在setupStatefulComponent创建一个代理对象[还是那个传来的type对象]将其绑定到instance对象上---传入instance触发setcurrentinstance---handlesetupResult基于setup中的props和context做出一定的处理---1.setup返回一个函数[会把它当成render函数去写] 2.setup返回一个对象[赋值,调用finishComponentSetup,如果没有render会将Component的render赋值给它]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><strong>往回走走到</strong><em><strong>setupComponent</strong></em>，instance.update使用effect调用componentUpdateFn---该函数中要调用传来对象里的render函数获取vnode子组件生成好的虚拟节点---在componentUpdateFn触发<em><strong>patch</strong></em>(递归回去了)【!此时已经变成<strong>element</strong>元素类型了!】</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><strong>updateComponent</strong> 更新</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>element</strong> 元素类型---调用processElement---根据!n1分成初始化or更新</p>
</blockquote>
<blockquote>
<blockquote>
<p><strong>mountElement</strong> 初始化(把虚拟节点转化成一个真实的dom元素)---创建el(真实的element)---[文本类型调用hostcreateElement]---[数组类型调用mountChildren]传入childer节点,el---遍历数组触发<em><strong>patch</strong></em>(递归)【!此时数组元素就是<strong>element</strong>类型!】</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><strong>仍然位于mountElement函数中,如果元素props存在,遍历调用****hostPatchProp</strong>(传入el,key,null,val)---分类,内部处理还是调用了dom内部的API</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><strong>返回mountElement函数,下一步调用****hostInsert</strong>(el,container[根组件])[将所有的一切插回#root根元素组件]到此所有元素就都在页面上展示出来了，也就是初始化的全过程</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><strong>patchElement</strong></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>**通俗来说：**<em><strong>调用render就是“拆箱”的过程</strong></em>直到把内部所有的组件渲染到浏览器上</p>
</blockquote>
<h3 id="update-更新流程"><a href="#update-更新流程" class="headerlink" title="update 更新流程"></a>update 更新流程</h3><p><strong>App.js 样例变动</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;//一个对象</span><br><span class="line">    name: &quot;App&quot;,//标记当前组件的名字</span><br><span class="line">    setup(props,context) &#123;//一个在组件创建之前执行的函数，可使用响应式数据、生命周期钩子、计算属性等</span><br><span class="line">        const count = ref(10)</span><br><span class="line">        window.count = count</span><br><span class="line">        </span><br><span class="line">        return&#123;</span><br><span class="line">            count,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render() &#123;//把template转化成render函数，代表这个组件想要渲染出来的视图</span><br><span class="line">        //tag标签名(div)  props属性对象  children数据包含了(div 元素的子节点)</span><br><span class="line">        return h(&quot;div&quot;, &#123; tId: 1 &#125;, [h(&quot;p&quot;, &#123;&#125;, &quot;主页&quot; + this.count)]);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>响应式的值发生改变(响应式对象都在render函数内)---执行用户传入的fn---判断是否初始化---触发当前组件的effect函数执行(instance,update)---调用render函数(获取前后虚拟节点树节点)---触发</strong><em><strong>patch</strong></em>(前后虚拟节点树节点)---根据!n2分成<strong>component</strong>组件类型or<strong>element</strong>元素类型</p>
<p><em><em>更新逻辑：<strong><em><strong>processXXX</strong></em>中n1存在---进入</strong></em>updateXXX</em>**(n1,n2)---取出新(n1&amp;n2)老(n2&amp;{})props---n2.el=n1.el---对比props(patchProps)---对比children(patchChild)双端对比算法实现</p>
</blockquote>
<h1 id="逐步搭建"><a href="#逐步搭建" class="headerlink" title="逐步搭建"></a>逐步搭建</h1><h2 id="初始化项目-搭建环境"><a href="#初始化项目-搭建环境" class="headerlink" title="初始化项目+搭建环境"></a>初始化项目+搭建环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install --save-dev jest</span><br><span class="line">pnpm add typescript --save-dev</span><br><span class="line">npx tsc --init</span><br><span class="line">pnpm add --save-dev jest</span><br><span class="line">pnpm i --save-dev @types/node</span><br></pre></td></tr></table></figure>

<p><strong>替换 package.json &amp; tsconfig.json</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;jest&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;types&quot;: [&quot;jest&quot;],</span><br><span class="line">&quot;noImplicitAny&quot;: false,//把any报错忽略掉</span><br></pre></td></tr></table></figure>

<p><strong>配置bable环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add --save-dev babel-jest @babel/core @babel/preset-env @babel/preset-typescript</span><br></pre></td></tr></table></figure>

<p><strong>根目录下创建一个</strong> <code>babel.config.js</code>文件</p>
<blockquote>
<p><strong>以当前node版本做一个转换 | 支持TS</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [&#x27;@babel/preset-env&#x27;, &#123;targets: &#123;node: &#x27;current&#x27;&#125;&#125;],</span><br><span class="line">    &#x27;@babel/preset-typescript&#x27;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>编写测试文件</strong></p>
<p><strong>reactivity / index.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function sum(a, b) &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>reactivity / tests / index.spec.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(&#x27;index&#x27;, () =&gt; &#123;</span><br><span class="line">    expect(1).toBe(1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>单测运行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm test</span><br></pre></td></tr></table></figure>

<h2 id="runtime-reactivity-响应式系统实现"><a href="#runtime-reactivity-响应式系统实现" class="headerlink" title="runtime-reactivity 响应式系统实现"></a>runtime-reactivity 响应式系统实现</h2><h3 id="编写单测"><a href="#编写单测" class="headerlink" title="编写单测"></a>编写单测</h3><h4 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h4><p><strong>reactivity / texts / effect.spec.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; effect &#125; from &#x27;../effect&#x27;</span><br><span class="line">import &#123; reactive &#125; from &#x27;../reactive&#x27;</span><br><span class="line"></span><br><span class="line">describe(&#x27;effect&#x27;, () =&gt; &#123;</span><br><span class="line">    it.skip(&#x27;effect&#x27;, () =&gt; &#123;</span><br><span class="line">        const user = reactive(&#123;// 响应式对象</span><br><span class="line">            age: 10,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        let nextAge</span><br><span class="line">        effect(() =&gt; &#123;//收集依赖 接收fn 触发get操作</span><br><span class="line">            nextAge = user.age + 1</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        expect(nextAge).toBe(11)</span><br><span class="line"></span><br><span class="line">        // update 触发set操作</span><br><span class="line">        user.age++</span><br><span class="line">        expect(nextAge).toBe(12)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h4><p><strong>reactivity / texts / reactive.spec.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive &#125; from &#x27;../reactive&#x27;</span><br><span class="line"></span><br><span class="line">describe(&#x27;reactive&#x27;, () =&gt; &#123;</span><br><span class="line">    it(&#x27;reactive&#x27;, () =&gt; &#123;</span><br><span class="line">        const original = &#123; age: 1 &#125;</span><br><span class="line">        const observed = reactive(original)</span><br><span class="line">        expect(observed).not.toBe(original)</span><br><span class="line">        expect(observed.age).toBe(1)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="实现reactive"><a href="#实现reactive" class="headerlink" title="实现reactive"></a>实现reactive</h3><p><strong>tsconfig.json</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;lib&quot;: [&quot;DOM&quot;,&quot;ES6&quot;], </span><br></pre></td></tr></table></figure>

<p><strong>reactivity / reactive.ts</strong></p>
<blockquote>
<p><strong>传入一个对象，返回一个Proxy对象，实现 get &amp; set 函数</strong></p>
<blockquote>
<p><strong>详解 假设对象为 { foo : 1 }</strong></p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target: &#123; foo : 1 &#125;</span><br><span class="line">key: foo</span><br><span class="line">value: 1</span><br></pre></td></tr></table></figure></blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export function reactive(raw) &#123;</span><br><span class="line">    return new Proxy(raw, &#123;</span><br><span class="line">        get(target, key) &#123;</span><br><span class="line">            const res = Reflect.get(target, key)</span><br><span class="line"></span><br><span class="line">            // TODO:收集依赖</span><br><span class="line"></span><br><span class="line">            return res</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        set(target, key, value) &#123;</span><br><span class="line">            const res = Reflect.set(target, key, value)</span><br><span class="line">            </span><br><span class="line">            // TODO:触发依赖</span><br><span class="line"></span><br><span class="line">            return res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>测试 pnpm test reactive</strong></p>
</blockquote>
<h3 id="实现effect"><a href="#实现effect" class="headerlink" title="实现effect"></a>实现effect</h3><p><strong>reactivity / effect.ts</strong></p>
<blockquote>
<p><strong>传入一个副作用函数fn，响应式数据发生变化时，重新执行fn</strong></p>
<blockquote>
<p>**封装类，将 **<code>_fn</code> 私有属性和 <code>run</code> 方法封装在一起，外部代码只能通过 <code>run</code> 方法来执行 <code>_fn</code>，隐藏内部实现细节，提高代码的安全性和可维护性</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ReactiveEffect &#123;</span><br><span class="line">private _fn: any</span><br><span class="line"> constructor(fn) &#123;</span><br><span class="line">     this._fn = fn</span><br><span class="line"> &#125;</span><br><span class="line"> run() &#123;</span><br><span class="line">     this._fn()</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export function effect(fn) &#123;</span><br><span class="line">    const _effect = new ReactiveEffect(fn)</span><br><span class="line"></span><br><span class="line">    _effect.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>测试 pnpm test effect</strong></p>
</blockquote>
<h3 id="实现reactive-get"><a href="#实现reactive-get" class="headerlink" title="实现reactive-get"></a>实现reactive-get</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get(target, key) &#123;</span><br><span class="line">    const res = Reflect.get(target, key)</span><br><span class="line"></span><br><span class="line">    track(target, key) //传入对象和key</span><br><span class="line"></span><br><span class="line">    return res</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="track-依赖收集"><a href="#track-依赖收集" class="headerlink" title="track 依赖收集"></a>track 依赖收集</h4><p><strong>reactivity / effect.ts</strong></p>
<blockquote>
<p><strong>构建一个容器，存储依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const targetMap = new Map() // 存储依赖关系</span><br></pre></td></tr></table></figure></blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const targetMap = new Map() // 存所有依赖</span><br><span class="line">export function track(target, key) &#123;</span><br><span class="line">    let depsMap = targetMap.get(target)</span><br><span class="line">    if (!depsMap) &#123;</span><br><span class="line">        depsMap = new Map()</span><br><span class="line">        targetMap.set(target, depsMap)//targetMap结构[target&lt;obj&gt;, depsMap&lt;map&gt;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let dep = depsMap.get(key)</span><br><span class="line">    if (!dep) &#123;</span><br><span class="line">        dep = new Set()</span><br><span class="line">        depsMap.set(key, dep)//depsMap结构[key&lt;key&gt;, dep&lt;ReactiveEffect&gt;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dep.add(？)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何拿到fn</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//全局对象</span><br><span class="line">let activeEffect</span><br><span class="line"></span><br><span class="line">//ReactiveEffect类内</span><br><span class="line">run() &#123;</span><br><span class="line">    activeEffect = this</span><br><span class="line">    this._fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//传入effect</span><br><span class="line">dep.add(activeEffect)</span><br></pre></td></tr></table></figure>

<h3 id="实现reactive-set"><a href="#实现reactive-set" class="headerlink" title="实现reactive-set"></a>实现reactive-set</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set(target, key, value) &#123;</span><br><span class="line">    const res = Reflect.set(target, key, value)</span><br><span class="line"></span><br><span class="line">    trigger(target, key) //传入对象和key</span><br><span class="line">    </span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="trigger-依赖触发"><a href="#trigger-依赖触发" class="headerlink" title="trigger 依赖触发"></a>trigger 依赖触发</h4><p><strong>reactivity / effect.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export function trigger(target, key) &#123;</span><br><span class="line">    let depsMap = targetMap.get(target)</span><br><span class="line">    if (!depsMap) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let dep = depsMap.get(key)</span><br><span class="line">    if (!dep) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dep.forEach((effect) =&gt; &#123;</span><br><span class="line">        effect.run()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>测试 pnpm test effect</strong></p>
</blockquote>
<h3 id="完善effect功能"><a href="#完善effect功能" class="headerlink" title="完善effect功能"></a>完善effect功能</h3><h4 id="功能单测1"><a href="#功能单测1" class="headerlink" title="功能单测1"></a>功能单测1</h4><p><strong>reactivity / texts / effect.spec.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">it(&#x27;返回runner可以触发effect&#x27;, () =&gt; &#123;</span><br><span class="line">    let foo = 10</span><br><span class="line">    const runner = effect(() =&gt; &#123;</span><br><span class="line">        foo++</span><br><span class="line">        return foo</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    expect(foo).toBe(11)//创建effect - foo++</span><br><span class="line">    const r = runner()//调用runner - foo++</span><br><span class="line">    expect(foo).toBe(12)</span><br><span class="line">    expect(r).toBe(foo)//调用runner - foo++</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>修改effect逻辑</strong></p>
<p><em>实现创建实例时run一次</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export function effect(fn) &#123;</span><br><span class="line">	const _effect = new ReactiveEffect(fn)</span><br><span class="line"></span><br><span class="line">	_effect.run() //先执行一次</span><br><span class="line"></span><br><span class="line">    return _effect.run.bind(_effect)//返回run函数并绑定this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run() &#123;</span><br><span class="line">    activeEffect = this</span><br><span class="line">    return this._fn()//返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>**Tips：有关 *****.bind(...)***</p>
<p>**直接返回 **<code>_effect.run</code> 会让 <code>run</code> 方法在调用时 <code>this</code> 指向出现问题，可能导致 <code>this._fn()</code> 无法正常执行。</p>
<p><em>例子</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class ReactiveEffect &#123;</span><br><span class="line">private _fn: any;</span><br><span class="line">constructor(fn) &#123;</span><br><span class="line">this._fn = fn;</span><br><span class="line">&#125;</span><br><span class="line">run() &#123;</span><br><span class="line">console.log(&#x27;this:&#x27;, this);</span><br><span class="line">this._fn();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function effectWithBind(fn) &#123;// 返回 _effect.run.bind(_effect)</span><br><span class="line">const _effect = new ReactiveEffect(fn);</span><br><span class="line">_effect.run();</span><br><span class="line">return _effect.run.bind(_effect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function effectWithoutBind(fn) &#123;// 返回 _effect.run</span><br><span class="line">const _effect = new ReactiveEffect(fn);</span><br><span class="line">_effect.run();</span><br><span class="line">return _effect.run;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const boundRun = effectWithBind(f);// 使用 effectWithBind</span><br><span class="line">boundRun(); // this 指向 _effect 实例</span><br><span class="line"></span><br><span class="line">const unboundRun = effectWithoutBind(f);// 使用 effectWithoutBind</span><br><span class="line">unboundRun(); // this 指向全局对象（在浏览器中是 window）</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p><strong>测试 pnpm test effect</strong></p>
</blockquote>
<h4 id="功能单测2"><a href="#功能单测2" class="headerlink" title="功能单测2"></a>功能单测2</h4><p><strong>reactivity / texts / effect.spec.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">it.skip(&quot;scheduler&quot;, () =&gt; &#123;</span><br><span class="line">    // 1. 通过 effect 的第二个参数给定一个 scheduler 的 fn</span><br><span class="line">    // 2. effect 第一次执行的时候 还会执行 fn</span><br><span class="line">    // 3. 当 响应式对象 set update 不会执行 fn 而是执行 scheduler</span><br><span class="line">    // 4. 如果说当执行 runner 的时候 会再次执行 fn</span><br><span class="line">    let dummy</span><br><span class="line">    let run: any</span><br><span class="line">    const scheduler = jest.fn(() =&gt; &#123;</span><br><span class="line">        run = runner</span><br><span class="line">    &#125;)</span><br><span class="line">    const obj = reactive(&#123; foo: 1 &#125;)</span><br><span class="line">    const runner = effect(() =&gt; </span><br><span class="line">		&#123; dummy = obj.foo &#125;,</span><br><span class="line">		&#123; scheduler &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    expect(scheduler).not.toHaveBeenCalled()//scheduler不会被调用</span><br><span class="line">    expect(dummy).toBe(1)</span><br><span class="line"></span><br><span class="line">    //当响应式对象set时调用scheduler,但不会执行fn</span><br><span class="line">    obj.foo++</span><br><span class="line">    expect(scheduler).toHaveBeenCalledTimes(1)</span><br><span class="line">    expect(dummy).toBe(1)</span><br><span class="line"></span><br><span class="line">    //调用runner时执行fn</span><br><span class="line">    run()</span><br><span class="line">    expect(dummy).toBe(2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>更新effect函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">constructor(fn, public scheduler?) &#123;//拿到可选参数scheduler</span><br><span class="line">    this._fn = fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function effect(fn, options: any = &#123;&#125;) &#123;</span><br><span class="line">    const scheduler = options.scheduler//拿到scheduler</span><br><span class="line">    const _effect = new ReactiveEffect(fn, scheduler)//给类传入scheduler</span><br><span class="line"></span><br><span class="line">    _effect.run()</span><br><span class="line">    return _effect.run.bind(_effect)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改更新函数trigger逻辑</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dep.forEach((effect) =&gt; &#123;</span><br><span class="line">    if (effect.scheduler) &#123;</span><br><span class="line">        effect.scheduler()</span><br><span class="line">        return</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        effect.run()</span><br><span class="line">    &#125;</span><br><span class="line">    effect.run()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>pnpm test effect</strong></p>
</blockquote>
<h4 id="功能单测3"><a href="#功能单测3" class="headerlink" title="功能单测3"></a>功能单测3</h4><p><strong>reactivity / texts / effect.spec.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">it(&quot;stop的执行逻辑&quot;, () =&gt; &#123;</span><br><span class="line">    let dummy</span><br><span class="line">    const obj = reactive(&#123; prop: 1 &#125;)</span><br><span class="line">    const runner = effect(() =&gt; &#123;</span><br><span class="line">        dummy = obj.prop</span><br><span class="line">    &#125;)</span><br><span class="line">    obj.prop = 2</span><br><span class="line">    expect(dummy).toBe(2)</span><br><span class="line"></span><br><span class="line">    stop(runner)//停止执行runner</span><br><span class="line"></span><br><span class="line">    obj.prop = 3</span><br><span class="line">    expect(dummy).toBe(2)</span><br><span class="line"></span><br><span class="line">    runner()</span><br><span class="line">    expect(dummy).toBe(3)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>reactivity / effect.ts</strong></p>
<p><strong>实现stop代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function stop(runner) &#123;</span><br><span class="line">    runner.effect.stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改effect函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export function effect(fn, options: any = &#123;&#125;) &#123;</span><br><span class="line">    const scheduler = options.scheduler</span><br><span class="line">    const _effect = new ReactiveEffect(fn, scheduler)</span><br><span class="line"></span><br><span class="line">    _effect.run()</span><br><span class="line"></span><br><span class="line">    const runner: any = _effect.run.bind(_effect) //定义runner函数并绑定this</span><br><span class="line">    runner.effect = _effect //将effect挂载到runner上</span><br><span class="line"></span><br><span class="line">    return runner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>track（依赖收集）函数添加逻辑</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dep.add(activeEffect)</span><br><span class="line">activeEffect.deps.push(dep)</span><br></pre></td></tr></table></figure>

<p><strong>修改effect类 | 添加stop函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public deps = []</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">    this.deps.forEach((dep:any) =&gt; &#123;</span><br><span class="line">        dep.delete(this)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>pnpm test effect --watch</strong></p>
</blockquote>
<p><strong>代码优化（抽离清除逻辑 &amp; 防抖）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">active = true</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">        cleanupEffect(this)</span><br><span class="line">        this.active = false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cleanupEffect(effect) &#123;</span><br><span class="line">    effect.deps.forEach((dep: any) =&gt; &#123;</span><br><span class="line">        dep.delete(effect)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能单测4"><a href="#功能单测4" class="headerlink" title="功能单测4"></a>功能单测4</h4><p><strong>reactivity / texts / effect.spec.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">it(&#x27;onStop的执行逻辑&#x27;, () =&gt; &#123;</span><br><span class="line">    const obj = reactive(&#123;</span><br><span class="line">        foo: 1,</span><br><span class="line">    &#125;)</span><br><span class="line">    const onStop = jest.fn()//jest.fn() 创建一个模拟函数 onStop，用于记录其调用次数和参数</span><br><span class="line">    let dummy</span><br><span class="line">    const runner = effect(</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">            dummy = obj.foo//响应式对象</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            onStop,//选项对象</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    stop(runner)</span><br><span class="line">    expect(onStop).toBeCalledTimes(1)//验证 onStop 函数是否被调用了一次</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>reactivity / effect.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//_effect.onStop = options.onStop//调用类方法</span><br><span class="line">//Object.assign(_effect, options)//调用类方法(优化)</span><br><span class="line">extend(_effect, options)//调用类方法(抽离封装)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Tip：二者区别</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 假设 options 对象如下</span><br><span class="line">const options = &#123;</span><br><span class="line">onStop: () =&gt; console.log(&#x27;Effect stopped&#x27;),</span><br><span class="line">someOtherOption: &#x27;value&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">const _effect = new ReactiveEffect(() =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 仅赋值 onStop 属性</span><br><span class="line">_effect.onStop = options.onStop;</span><br><span class="line"></span><br><span class="line">console.log(_effect.onStop); // 输出: () =&gt; console.log(&#x27;Effect stopped&#x27;)</span><br><span class="line">console.log(_effect.someOtherOption); // 输出: undefined</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 复制 options 对象的所有属性到 _effect</span><br><span class="line">Object.assign(_effect, options);</span><br><span class="line"></span><br><span class="line">console.log(_effect.onStop); // 输出: () =&gt; console.log(&#x27;Effect stopped&#x27;)</span><br><span class="line">console.log(_effect.someOtherOption); // 输出: &#x27;value&#x27;</span><br></pre></td></tr></table></figure></blockquote>
<p><strong>继续抽离函数</strong></p>
<p><strong>src / shared (放置通用的工具函数) / index.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const extend = Object.assign</span><br></pre></td></tr></table></figure>

<p><strong>修改类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onStop?: () =&gt; void</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">        cleanupEffect(this)</span><br><span class="line">        if (this.onStop) &#123;</span><br><span class="line">            this.onStop()</span><br><span class="line">        &#125;</span><br><span class="line">        this.active = false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现readonly功能"><a href="#实现readonly功能" class="headerlink" title="实现readonly功能"></a>实现readonly功能</h3><h4 id="编写单测-1"><a href="#编写单测-1" class="headerlink" title="编写单测"></a>编写单测</h4><p><strong>readonly.spec.ts</strong></p>
<blockquote>
<p><strong>只读属性只能读取set不能被改写set</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; readonly &#125; from &#x27;../reactive&#x27;</span><br><span class="line"></span><br><span class="line">describe(&#x27;readonly&#x27;, () =&gt; &#123;</span><br><span class="line">	it(&#x27;readonly&#x27;, () =&gt; &#123;</span><br><span class="line">		const original = &#123; foo: 1 &#125;</span><br><span class="line">		const wrapped = readonly(original)</span><br><span class="line">		expect(wrapped).not.toBe(original) //返回一个新对象，而非返回原对象</span><br><span class="line">		expect(wrapped.foo).toBe(1)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	it(&#x27;warning when call set&#x27;, () =&gt; &#123;</span><br><span class="line">		console.warn = jest.fn()</span><br><span class="line">		const user = readonly(&#123;</span><br><span class="line">			age: 10,</span><br><span class="line">		&#125;)</span><br><span class="line">		user.age = 11</span><br><span class="line">		expect(console.warn).toBeCalled()//调用了console.warn</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>reactive</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export function readonly(raw) &#123;</span><br><span class="line">    return new Proxy(raw, &#123;</span><br><span class="line">        get(target, key) &#123;</span><br><span class="line">            return Reflect.get(target, key)</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target, key, value) &#123;</span><br><span class="line">            console.warn(`key: $&#123;key&#125; set 失败，因为 target 是 readonly 的`, target)</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽离 get &amp; set 函数</strong></p>
<p><strong>createGetter</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function createGetter(isReadonly = false, shallow = false) &#123;</span><br><span class="line">    return function get(target, key) &#123;//返回一个get函数</span><br><span class="line">        const res = Reflect.get(target, key)</span><br><span class="line">        if (!isReadonly) &#123;</span><br><span class="line">            track(target, key)</span><br><span class="line">        &#125;</span><br><span class="line">        if (shallow) &#123;</span><br><span class="line">            return res</span><br><span class="line">        &#125;</span><br><span class="line">        if (typeof res === &#x27;object&#x27;) &#123;</span><br><span class="line">            return isReadonly ? readonly(res) : reactive(res)</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>createSetter</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createSetter(shallow = false) &#123;</span><br><span class="line">    return function set(target, key, value) &#123;</span><br><span class="line">        const res = Reflect.set(target, key, value)</span><br><span class="line">        trigger(target, key)</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改写函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export function reactive(raw) &#123;</span><br><span class="line">    return new Proxy(raw, &#123;</span><br><span class="line">        get: createGetter(),</span><br><span class="line">        set: createSetter(),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function readonly(raw) &#123;</span><br><span class="line">    return new Proxy(raw, &#123;</span><br><span class="line">        get: createGetter(true),</span><br><span class="line">        set(target, key, value) &#123;</span><br><span class="line">            console.warn(`key: $&#123;key&#125; set 失败，因为 target 是 readonly 的`, target)</span><br><span class="line">            return true</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继续优化抽离组件</strong></p>
<p><strong>创建 baseHanders.ts | 封装get逻辑</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#123; track, trigger &#125; from &#x27;./effect&#x27;</span><br><span class="line"></span><br><span class="line">function createGetter(isReadonly = false) &#123;</span><br><span class="line">	return function get(target, key) &#123;</span><br><span class="line">		const res = Reflect.get(target, key)</span><br><span class="line">		if (!isReadonly) &#123;</span><br><span class="line">			track(target, key)</span><br><span class="line">		&#125;</span><br><span class="line">		return res</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSetter() &#123;</span><br><span class="line">	return function set(target, key, value) &#123;</span><br><span class="line">		const res = Reflect.set(target, key, value)</span><br><span class="line">		trigger(target, key)</span><br><span class="line">		return res</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const reactiveHandlers = &#123;</span><br><span class="line">	get: createGetter(),</span><br><span class="line">	set: createSetter(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const readonlyHandlers = &#123;</span><br><span class="line">	get: createGetter(true),</span><br><span class="line">	set(target, key, value) &#123;</span><br><span class="line">		console.warn(`key: $&#123;key&#125; set 失败，因为 target 是 readonly 的`, target)</span><br><span class="line">		return true</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重构 reactive &amp; readonly</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactiveHandlers, readonlyHandlers &#125; from &#x27;./baseHanders&#x27;</span><br><span class="line"></span><br><span class="line">function createActiveEffect(raw: any, baseHanders) &#123;</span><br><span class="line">	return new Proxy(raw, baseHanders)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function reactive(raw) &#123;</span><br><span class="line">	return createActiveEffect(raw, reactiveHandlers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function readonly(raw) &#123;</span><br><span class="line">	return createActiveEffect(raw, readonlyHandlers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为 createGetter 添加缓存机制</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const get = createGetter()</span><br><span class="line">const set = createSetter()</span><br><span class="line">const readonlyGet = createGetter(true)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>pnpm test readonly --watch</strong></p>
</blockquote>
<h3 id="实现-isReactive-isReadonly-功能"><a href="#实现-isReactive-isReadonly-功能" class="headerlink" title="实现 isReactive &amp; isReadonly 功能"></a>实现 isReactive &amp; isReadonly 功能</h3><h4 id="编写单测-2"><a href="#编写单测-2" class="headerlink" title="编写单测"></a>编写单测</h4><p><strong>reactive.spec.ts</strong></p>
<blockquote>
<p>**判断传入的 **<code>value</code> 是否为响应式对象</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it(&#x27;reactive&#x27;, () =&gt; &#123;</span><br><span class="line">    const original = &#123; age: 1 &#125;</span><br><span class="line">    const observed = reactive(original)</span><br><span class="line">    expect(observed).not.toBe(original)</span><br><span class="line">    expect(observed.age).toBe(1)</span><br><span class="line"></span><br><span class="line">    //判断是否是响应式对象</span><br><span class="line">    expect(isReactive(observed)).toBe(true)</span><br><span class="line">    expect(isReactive(original)).toBe(false)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>readonly.spec.ts</strong></p>
<blockquote>
<p><strong>判断是否是只读对象</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">it(&#x27;readonly&#x27;, () =&gt; &#123;</span><br><span class="line">    const original = &#123; foo: 1 &#125;</span><br><span class="line">    const wrapped = readonly(original)</span><br><span class="line">    expect(wrapped).not.toBe(original) //返回一个新对象，而非返回原对象</span><br><span class="line">    expect(wrapped.foo).toBe(1)</span><br><span class="line"></span><br><span class="line">    expect(isReadonly(wrapped)).toBe(true)//判断是否是只读对象</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h4><p><strong>createGetter拦截判断</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function createGetter(isReadonly = false) &#123;</span><br><span class="line">	return function get(target, key) &#123;</span><br><span class="line"></span><br><span class="line">		if (key === ReactiveFlags.IS_REACTIVE) &#123;//判断是否是响应式对象</span><br><span class="line">			return !isReadonly</span><br><span class="line">		&#125;else if (key === ReactiveFlags.IS_READONLY) &#123;//判断是否是只读对象</span><br><span class="line">			return isReadonly</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		const res = Reflect.get(target, key)</span><br><span class="line">		if (!isReadonly) &#123;</span><br><span class="line">			track(target, key)</span><br><span class="line">		&#125;</span><br><span class="line">		return res</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>reactive.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export const enum ReactiveFlags &#123;</span><br><span class="line">	IS_REACTIVE = &#x27;__v_isReactive&#x27;,</span><br><span class="line">	IS_READONLY = &#x27;__v_isReadonly&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function isReactive(value) &#123;//判断是否是响应式对象</span><br><span class="line">    return !!value[ReactiveFlags.IS_REACTIVE]</span><br><span class="line">&#125;</span><br><span class="line">export function isReadonly(value) &#123;//判断是否是只读对象</span><br><span class="line">    return !!value[ReactiveFlags.IS_READONLY]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>pnpm test readonly --watch</strong></p>
<p><strong>pnpm test reactive --watch</strong></p>
</blockquote>
<h3 id="stop功能优化"><a href="#stop功能优化" class="headerlink" title="stop功能优化"></a>stop功能优化</h3><h4 id="当前bug"><a href="#当前bug" class="headerlink" title="当前bug"></a>当前bug</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">it(&quot;stop的执行逻辑&quot;, () =&gt; &#123;</span><br><span class="line">    let dummy</span><br><span class="line">    const obj = reactive(&#123; prop: 1 &#125;)</span><br><span class="line">    const runner = effect(() =&gt; &#123;</span><br><span class="line">        dummy = obj.prop</span><br><span class="line">    &#125;)</span><br><span class="line">    obj.prop = 2</span><br><span class="line">    expect(dummy).toBe(2)</span><br><span class="line"></span><br><span class="line">    stop(runner)//停止执行runner</span><br><span class="line"></span><br><span class="line">    // obj.prop = 3 只涉及set操作</span><br><span class="line">    obj.prop++ //触发 get+set</span><br><span class="line">    </span><br><span class="line">    expect(dummy).toBe(2)</span><br><span class="line"></span><br><span class="line">    runner()</span><br><span class="line">    expect(dummy).toBe(3)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>stop(runner)会根据该响应式对象中active的状态清除它的已经收集的所有依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">effect.deps.forEach((dep: any) =&gt; &#123;</span><br><span class="line">dep.delete(effect)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>**+1触发get操作一定会触发track操作重新收集依赖 **</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep.add(activeEffect)//之前的依赖都白清了</span><br></pre></td></tr></table></figure>

<p><strong>所以stop函数之后的操作不应该收集依赖（不能触发track操作）</strong></p>
</blockquote>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>track添加逻辑</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(!activeEffect || !shouldTrack)&#123;//如果没有激活的effect或者shouldTrack为false，直接返回</span><br><span class="line">    return  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//...收集依赖</span><br><span class="line"></span><br><span class="line">if (dep.has(activeEffect)) &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">dep.add(activeEffect)</span><br><span class="line">activeEffect.deps.push(dep)</span><br></pre></td></tr></table></figure>

<p><strong>修改run函数（stop根据active状态区分）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">run() &#123;</span><br><span class="line">    if (!this.active) &#123; // stop状态直接返回fn</span><br><span class="line">        return this._fn()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shouldTrack = true // 允许进行依赖收集</span><br><span class="line">    activeEffect = this</span><br><span class="line"></span><br><span class="line">    const res = this._fn() // this._fn() 执行，期间访问响应式对象的属性，触发track依赖收集</span><br><span class="line"></span><br><span class="line">    shouldTrack = false // 依赖收集结束，后续操作不会再触发依赖收集。</span><br><span class="line"></span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>cleanupEffect添加逻辑</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">effect.deps.length = 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>pnpm test reactive --watch</strong></p>
</blockquote>
<h3 id="嵌套响应式转换"><a href="#嵌套响应式转换" class="headerlink" title="嵌套响应式转换"></a>嵌套响应式转换</h3><h4 id="编写单测-3"><a href="#编写单测-3" class="headerlink" title="编写单测"></a>编写单测</h4><p><strong>reactive</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">it(&#x27;嵌套响应式对象转换&#x27;, () =&gt; &#123;</span><br><span class="line">    const original = &#123;</span><br><span class="line">        nested: &#123;</span><br><span class="line">            foo: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        array: [&#123; bar: 2 &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">    const observed = reactive(original)</span><br><span class="line">    expect(isReactive(observed.nested)).toBe(true)</span><br><span class="line">    expect(isReactive(observed.array)).toBe(true)</span><br><span class="line">    expect(isReactive(observed.array[0])).toBe(true) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>readonly</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">it(&#x27;readonly&#x27;, () =&gt; &#123;</span><br><span class="line">    const original = &#123; foo: 1, bar: &#123; baz: 2 &#125; &#125;</span><br><span class="line">    const wrapped = readonly(original)</span><br><span class="line"></span><br><span class="line">    expect(wrapped).not.toBe(original) //返回一个新对象，而非返回原对象</span><br><span class="line">    expect(wrapped.foo).toBe(1)</span><br><span class="line"></span><br><span class="line">    expect(isReadonly(original)).toBe(false)</span><br><span class="line">    expect(isReadonly(original.bar)).toBe(false)</span><br><span class="line">    expect(isReadonly(wrapped)).toBe(true)//只读</span><br><span class="line">    expect(isReadonly(wrapped.bar)).toBe(true)//只读</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>baseHanders.ts 递归拦截</strong></p>
<blockquote>
<p><strong>createGetter函数</strong></p>
<p>**const res = Reflect.get(**<em>target</em>, <em>key</em>)后添加判断</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (isObject(res)) &#123;//判断是否是对象</span><br><span class="line">    return isReadonly ? readonly(res) : reactive(res)//返回只读对象或者响应式对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>shared / index.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export const isObject = (val) =&gt; &#123;</span><br><span class="line">    return val !== null &amp;&amp; typeof val === &#x27;object&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shallowReadonly工具函数"><a href="#shallowReadonly工具函数" class="headerlink" title="shallowReadonly工具函数"></a>shallowReadonly工具函数</h3><h4 id="编写单测-4"><a href="#编写单测-4" class="headerlink" title="编写单测"></a>编写单测</h4><p><strong>shallowReadonly.spec.ts</strong></p>
<blockquote>
<p><strong>数据展示:确保外层数据不会被意外修改，同时允许在必要时修改嵌套对象</strong></p>
<p><strong>性能优化:避免对所有嵌套对象进行只读处理</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; isReadonly, shallowReadonly &#125; from &#x27;../reactive&#x27;</span><br><span class="line"></span><br><span class="line">describe(&#x27;shallowReadonly&#x27;, () =&gt; &#123;</span><br><span class="line">    it(&#x27;shallowReadonly&#x27;, () =&gt; &#123;</span><br><span class="line">        const props = shallowReadonly(&#123; n: &#123; foo: 1 &#125; &#125;)</span><br><span class="line">        expect(isReadonly(props)).toBe(true)//表层只读</span><br><span class="line">        expect(isReadonly(props.n)).toBe(false)//内部正常</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="功能实现-1"><a href="#功能实现-1" class="headerlink" title="功能实现"></a>功能实现</h4><p><strong>reactive.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function shallowReadonly(raw) &#123;</span><br><span class="line">    return createActiveEffect(raw, shallowReadonlyHandlers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>baseHanders.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const readonlyGet = createGetter(true)</span><br><span class="line">const shallowReadonlyGet = createGetter(true, true)</span><br></pre></td></tr></table></figure>

<p><strong>createGetter改写</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createGetter(isReadonly = false, shallow = false)</span><br><span class="line"></span><br><span class="line">if (shallow) &#123;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line">//👇判断isObject前拦截👆//</span><br><span class="line">if (isObject(res)) &#123;//判断是否是对象</span><br><span class="line">    return isReadonly ? readonly(res) : reactive(res) //返回只读对象或者响应式对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承改写自readonlyHandlers</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export const shallowReadonlyHandlers = extend(&#123;&#125;, readonlyHandlers, &#123;</span><br><span class="line">    get: shallowReadonlyGet,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="实现isProxy功能"><a href="#实现isProxy功能" class="headerlink" title="实现isProxy功能"></a>实现isProxy功能</h3><h4 id="编写单测-5"><a href="#编写单测-5" class="headerlink" title="编写单测"></a>编写单测</h4><blockquote>
<p><strong>判断是否是代理对象</strong></p>
</blockquote>
<p><strong>reactive &amp; readonly 分别添加</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(isProxy(observed)).toBe(true)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(isProxy(wrapped)).toBe(true)</span><br></pre></td></tr></table></figure>

<h4 id="功能实现-2"><a href="#功能实现-2" class="headerlink" title="功能实现"></a>功能实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function isProxy(value) &#123; //判断是否是代理对象</span><br><span class="line">    return isReactive(value) || isReadonly(value)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现ref"><a href="#实现ref" class="headerlink" title="实现ref"></a>实现ref</h3><h4 id="必看：ref与-reactive区别"><a href="#必看：ref与-reactive区别" class="headerlink" title="必看：ref与 reactive区别"></a>必看：<code>ref</code>与 <code>reactive</code>区别</h4><table>
<thead>
<tr>
<th><strong>reactive</strong></th>
<th><strong>ref</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>❌只支持****对象</strong>和<strong>数组</strong>(引用数据类型)</td>
<td><strong>✅支持基本数据类型+引用数据类型</strong></td>
</tr>
<tr>
<td><strong>❌重新分配一个新对象会丢失响应性</strong></td>
<td><strong>✅重新分配一个新对象****不会</strong>失去响应</td>
</tr>
<tr>
<td><strong>❌将对象传入函数时,失去响应</strong></td>
<td><strong>✅传入函数时,不会失去响应</strong></td>
</tr>
<tr>
<td><strong>能直接访问属性</strong></td>
<td><strong>需要使用</strong> <code>.value</code>访问属性</td>
</tr>
<tr>
<td><strong>✅在</strong> <code>&lt;script&gt;</code>和 <code>&lt;template&gt;</code>中无差别使用</td>
<td><strong>❌在</strong> <code>&lt;script&gt;</code>和 <code>&lt;template&gt;</code>使用方式不同(script中要 <code>.value</code>)</td>
</tr>
<tr>
<td><strong>❌解构时会丢失响应性,需使用toRefs</strong></td>
<td><strong>❌解构对象时会丢失响应性,需使用toRefs</strong></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>ref只传单值，不能使用Proxy(Proxy对对象起作用)</strong></p>
<p><strong>ref中的任何一个点key都要对应一个dep，get&amp;set进行依赖收集和触发</strong></p>
</blockquote>
<h4 id="功能单测1-1"><a href="#功能单测1-1" class="headerlink" title="功能单测1"></a>功能单测1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; effect &#125; from &#x27;../effect&#x27;</span><br><span class="line">import &#123; ref &#125; from &#x27;../ref&#x27;</span><br><span class="line"></span><br><span class="line">describe(&#x27;ref&#x27;, () =&gt; &#123;</span><br><span class="line">    it.only(&#x27;value&#x27;, () =&gt; &#123;</span><br><span class="line">        const a = ref(1)</span><br><span class="line">        expect(a.value).toBe(1)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>ref.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class RefImpl &#123;</span><br><span class="line">    private _value: any;</span><br><span class="line">    constructor(value) &#123;//构造函数</span><br><span class="line">        this._value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get value() &#123;//获取value</span><br><span class="line">        return this._value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // set value() &#123;</span><br><span class="line"></span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function ref(value) &#123;</span><br><span class="line">    return new RefImpl(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能单测2-1"><a href="#功能单测2-1" class="headerlink" title="功能单测2"></a>功能单测2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">it(&#x27;should be reactive&#x27;, () =&gt; &#123;</span><br><span class="line">    const a = ref(1)</span><br><span class="line">    let dummy</span><br><span class="line">    let calls = 0</span><br><span class="line">    effect(() =&gt; &#123;</span><br><span class="line">        calls++</span><br><span class="line">        dummy = a.value</span><br><span class="line">    &#125;)</span><br><span class="line">    expect(calls).toBe(1)//effect执行了一次</span><br><span class="line">    expect(dummy).toBe(1)</span><br><span class="line">    a.value = 2</span><br><span class="line">    expect(calls).toBe(2)</span><br><span class="line">    expect(dummy).toBe(2)</span><br><span class="line">    // 值相同不会触发</span><br><span class="line">    a.value = 2</span><br><span class="line">    expect(calls).toBe(2)</span><br><span class="line">    expect(dummy).toBe(2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>ref.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class RefImpl &#123;</span><br><span class="line">    private _value: any //值</span><br><span class="line">    public dep //依赖就是唯一的value</span><br><span class="line">    constructor(value) &#123;</span><br><span class="line">        //构造函数</span><br><span class="line">        this._value = value //存储值</span><br><span class="line">        this.dep = new Set() //存储依赖</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get value() &#123;</span><br><span class="line">        //获取value</span><br><span class="line">        return this._value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set value(newValue) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function ref(value) &#123;</span><br><span class="line">    return new RefImpl(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>回到effect抽离 get &amp; set 逻辑代码复用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">	trackEffects(dep)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function trackEffects(dep) &#123;</span><br><span class="line">    if (dep.has(activeEffect)) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    dep.add(activeEffect)</span><br><span class="line">    activeEffect.deps.push(dep)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">	triggerEffects(dep)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function triggerEffects(dep) &#123; </span><br><span class="line">	dep.forEach((effect) =&gt; &#123;</span><br><span class="line">		if (effect.scheduler) &#123;</span><br><span class="line">			effect.scheduler()</span><br><span class="line">			return</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			effect.run()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ref.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">get value() &#123;</span><br><span class="line">    trackEffects(this.dep) //收集依赖</span><br><span class="line">    return this._value //获取value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set value(newValue) &#123;</span><br><span class="line">    this._value = newValue //设置value</span><br><span class="line">    triggerEffects(this.dep) //触发依赖</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现赋值相同不触发effect功能</strong></p>
<p><strong>set value添加</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(Object.is(newValue,this._value)) return //如果新值和旧值相等，直接返回</span><br></pre></td></tr></table></figure>

<p><strong>抽离封装成工具函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function trackRefValue(ref) &#123;</span><br><span class="line">    if (isTracking()) &#123;</span><br><span class="line">        trackEffects(ref.dep)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export const hasChange = (val, newValue) =&gt; &#123;</span><br><span class="line">    return !Object.is(val, newValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get &amp; set value改写</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get value() &#123;</span><br><span class="line">    trackRefValue(this) //收集依赖</span><br><span class="line">    return this._value //获取value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set value(newValue) &#123;</span><br><span class="line">    if (hasChange(newValue, this._value)) &#123;//判断是否有变化</span><br><span class="line">        this._value = newValue //设置value</span><br><span class="line">        triggerEffects(this.dep) //触发依赖</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能单测3-1"><a href="#功能单测3-1" class="headerlink" title="功能单测3"></a>功能单测3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">it(&#x27;嵌套响应&#x27;, () =&gt; &#123;</span><br><span class="line">    const a = ref(&#123;</span><br><span class="line">        count: 1,</span><br><span class="line">    &#125;)</span><br><span class="line">    let dummy</span><br><span class="line">    effect(() =&gt; &#123;</span><br><span class="line">        dummy = a.value.count</span><br><span class="line">    &#125;)</span><br><span class="line">    expect(dummy).toBe(1)</span><br><span class="line">    a.value.count = 2</span><br><span class="line">    expect(dummy).toBe(2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>要实现嵌套就设计递归嘛</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private _value: any //值</span><br><span class="line">public dep //依赖就是唯一的value</span><br><span class="line">private _rawValue: any //原始值</span><br><span class="line">constructor(value) &#123;</span><br><span class="line">    this._rawValue = value</span><br><span class="line">    this._value = isObject(value) ? reactive(value) : value //如果是对象，就递归</span><br><span class="line">    this.dep = new Set() //存储依赖</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set value(newValue) &#123;</span><br><span class="line">    if (hasChange(newValue, this._rawValue)) &#123;</span><br><span class="line">        //判断是否有变化</span><br><span class="line">        this._rawValue = newValue</span><br><span class="line">        this._value = isObject(newValue) ? reactive(newValue) : newValue</span><br><span class="line">        triggerEffects(this.dep) //触发依赖</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继续优化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private _rawValue: any //原始值</span><br><span class="line"></span><br><span class="line">set value(newValue) &#123;</span><br><span class="line">    if (hasChange(newValue, this._rawValue)) &#123;</span><br><span class="line">        //判断是否有变化</span><br><span class="line">        this._rawValue = newValue</span><br><span class="line">        this._value = convert(newValue) //如果是对象，就递归</span><br><span class="line">        triggerEffects(this.dep) //触发依赖</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function convert(value) &#123;</span><br><span class="line">    return isObject(value) ? reactive(value) : value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现isRef"><a href="#实现isRef" class="headerlink" title="实现isRef"></a>实现isRef</h3><h4 id="编写单测-6"><a href="#编写单测-6" class="headerlink" title="编写单测"></a>编写单测</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it(&#x27;isRef&#x27;, () =&gt; &#123;</span><br><span class="line">    const a = ref(1)</span><br><span class="line">    const user = &#123;</span><br><span class="line">        age: a,</span><br><span class="line">    &#125;</span><br><span class="line">    expect(isRef(a)).toBe(true)</span><br><span class="line">    expect(isRef(1)).toBe(false)</span><br><span class="line">    expect(isRef(user)).toBe(false)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="功能实现-3"><a href="#功能实现-3" class="headerlink" title="功能实现"></a>功能实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public __v_isRef = true //标识是否是ref</span><br><span class="line"></span><br><span class="line">export function isRef(ref) &#123;</span><br><span class="line">    return !!ref.__v_isRef//转换为布尔值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现unRef"><a href="#实现unRef" class="headerlink" title="实现unRef"></a>实现unRef</h3><blockquote>
<p><strong>如果参数是 ref，则返回内部值，否则返回参数本身</strong></p>
</blockquote>
<h4 id="编写单测-7"><a href="#编写单测-7" class="headerlink" title="编写单测"></a>编写单测</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it(&#x27;unRef&#x27;, () =&gt; &#123;//</span><br><span class="line">    const a = ref(1)</span><br><span class="line">    expect(unRef(a)).toBe(1)</span><br><span class="line">    expect(unRef(1)).toBe(1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="功能实现-4"><a href="#功能实现-4" class="headerlink" title="功能实现"></a>功能实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function unRef(ref) &#123;</span><br><span class="line">    return isRef(ref) ? ref.value : ref //如果是ref，就返回value，否则返回原对象   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现proxyRefs"><a href="#实现proxyRefs" class="headerlink" title="实现proxyRefs (?)"></a>实现proxyRefs (?)</h3><h4 id="编写单测-8"><a href="#编写单测-8" class="headerlink" title="编写单测"></a>编写单测</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">it(&#x27;proxyRefs&#x27;, () =&gt; &#123;</span><br><span class="line">    const user = &#123;</span><br><span class="line">        age: ref(10),</span><br><span class="line">        name: &#x27;zf&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">    const proxyUser = proxyRefs(user)</span><br><span class="line">    expect(user.age.value).toBe(10)</span><br><span class="line">    expect(proxyUser.age).toBe(10)//可以省略.value</span><br><span class="line">    expect(proxyUser.name).toBe(&#x27;zf&#x27;)//可以省略.value</span><br><span class="line"></span><br><span class="line">    proxyUser.age = 20</span><br><span class="line">    expect(proxyUser.age).toBe(20)</span><br><span class="line">    expect(user.age.value).toBe(20)</span><br><span class="line"></span><br><span class="line">    proxyUser.age = ref(10)</span><br><span class="line">    expect(proxyUser.age).toBe(10)</span><br><span class="line">    expect(user.age.value).toBe(10)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="功能实现-5"><a href="#功能实现-5" class="headerlink" title="功能实现"></a>功能实现</h4><blockquote>
<p><strong>逻辑：</strong></p>
<p><strong>get到ref返回.value，否则直接返回原对象</strong></p>
<p><strong>实例对象触发set会连锁原对象值改变</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export function proxyRefs(objectWithRefs) &#123;</span><br><span class="line">    return new Proxy(objectWithRefs, &#123;</span><br><span class="line">        get(target, key) &#123;</span><br><span class="line">            return unRef(Reflect.get(target, key)) //如果是ref，就返回value，否则返回原对象</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target, key, value) &#123;</span><br><span class="line">            if (isRef(target[key]) &amp;&amp; !isRef(value)) &#123;</span><br><span class="line">                return (target[key].value = value) //如果是ref，就返回value，否则返回原对象</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return Reflect.set(target, key, value) //如果是ref，就返回value，否则返回原对象</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现computed"><a href="#实现computed" class="headerlink" title="实现computed"></a>实现computed</h3><blockquote>
<p>**接受一个 **<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description">getter 函数</a>，返回一个只读的响应式 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-core.html#ref">ref</a> 对象。该 ref 通过 <code>.value</code> 暴露 getter 函数的返回值。它也可以接受一个带有 <code>get</code> 和 <code>set</code> 函数的对象来创建一个可写的 ref 对象。</p>
</blockquote>
<h4 id="功能单测1-2"><a href="#功能单测1-2" class="headerlink" title="功能单测1"></a>功能单测1</h4><p><strong>computed.spec.ts</strong></p>
<blockquote>
<p><code>computed</code> 函数会基于这个 getter 函数创建一个计算属性 <code>age</code>，该计算属性的值会根据 <code>user.age</code> 的变化而自动更新。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; computed &#125; from &#x27;../computed&#x27;</span><br><span class="line">import &#123; reactive &#125; from &#x27;../reactive&#x27;</span><br><span class="line"></span><br><span class="line">describe(&#x27;computed&#x27;, () =&gt; &#123;</span><br><span class="line">    it(&#x27;computed&#x27;, () =&gt; &#123;</span><br><span class="line">        const user = reactive(&#123;</span><br><span class="line">            age: 1,</span><br><span class="line">        &#125;)</span><br><span class="line">        const age = computed(() =&gt; &#123;</span><br><span class="line">            return user.age</span><br><span class="line">        &#125;)</span><br><span class="line">        expect(age.value).toBe(1)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>computed.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ComputedRefImpl &#123;</span><br><span class="line">    private _getter: any</span><br><span class="line">    constructor(getter) &#123;</span><br><span class="line">        this._getter = getter</span><br><span class="line">    &#125;</span><br><span class="line">    get value() &#123;</span><br><span class="line">        return this._getter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function computed(getter) &#123;</span><br><span class="line">    return new ComputedRefImpl(getter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能单测2-2"><a href="#功能单测2-2" class="headerlink" title="功能单测2"></a>功能单测2</h4><p><strong>computed.spec.ts</strong></p>
<blockquote>
<p>**接受一个 **<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description">getter 函数</a>，返回一个只读的响应式 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-core.html#ref">ref</a> 对象。该 ref 通过 <code>.value</code> 暴露 getter 函数的返回值。它也可以接受一个带有 <code>get</code> 和 <code>set</code> 函数的对象来创建一个可写的 ref 对象。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">it(&#x27;should compute lazily&#x27;, () =&gt; &#123;</span><br><span class="line">    const value = reactive(&#123;</span><br><span class="line">        foo: 1,</span><br><span class="line">    &#125;)</span><br><span class="line">    const getter = jest.fn(() =&gt; &#123;</span><br><span class="line">        return value.foo</span><br><span class="line">    &#125;)</span><br><span class="line">    const cValue = computed(getter)</span><br><span class="line">    expect(getter).not.toHaveBeenCalled()</span><br><span class="line">    expect(cValue.value).toBe(1)</span><br><span class="line">    expect(getter).toHaveBeenCalledTimes(1)</span><br><span class="line">    // 再次访问，不应该再调用</span><br><span class="line">    cValue.value</span><br><span class="line">    expect(getter).toHaveBeenCalledTimes(1)</span><br><span class="line">    // 不应该再调用</span><br><span class="line">    value.foo = 2</span><br><span class="line">    expect(getter).toHaveBeenCalledTimes(1)</span><br><span class="line">    // 触发getter</span><br><span class="line">    expect(cValue.value).toBe(2)</span><br><span class="line">    expect(getter).toHaveBeenCalledTimes(2)</span><br><span class="line">    // 不应该再调用</span><br><span class="line">    cValue.value</span><br><span class="line">    expect(getter).toHaveBeenCalledTimes(2)   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>computed.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ReactiveEffect &#125; from &#x27;./effect&#x27;</span><br><span class="line"></span><br><span class="line">class ComputedRefImpl &#123;</span><br><span class="line">    private _getter: any</span><br><span class="line">    private _value: any</span><br><span class="line">    private _dirty: boolean = true</span><br><span class="line">    private _effect: any</span><br><span class="line">    constructor(getter) &#123;</span><br><span class="line">        this._getter = getter</span><br><span class="line">        this._effect = new ReactiveEffect(getter, () =&gt; &#123;</span><br><span class="line">            if (!this._dirty) &#123;</span><br><span class="line">                this._dirty = true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    get value() &#123;</span><br><span class="line">        if (this._dirty) &#123;</span><br><span class="line">            this._dirty = false</span><br><span class="line">            this._value = this._effect.run()</span><br><span class="line">        &#125;</span><br><span class="line">        return this._value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function computed(getter) &#123;</span><br><span class="line">    return new ComputedRefImpl(getter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="runtime-core-初始化流程实现"><a href="#runtime-core-初始化流程实现" class="headerlink" title="runtime-core 初始化流程实现"></a>runtime-core 初始化流程实现</h2><h3 id="总览导图"><a href="#总览导图" class="headerlink" title="总览导图"></a>总览导图</h3><blockquote>
<p><strong>全程跟着这个流程图实现</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="file:///C:/Users/DELL/Downloads/runtime-core.jpg?lastModify=1740547033" alt="runtime-core"></p>
<p><strong>创建src / runtime-core文件夹</strong></p>
<blockquote>
<p><strong>这次的测试样例放在根目录下的example / helloworld</strong></p>
</blockquote>
<h3 id="初始化-component-主流程"><a href="#初始化-component-主流程" class="headerlink" title="初始化 component 主流程"></a>初始化 component 主流程</h3><h4 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h4><p><strong>example / helloworld / index.html</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">        &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;script src=&quot;main.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>以下文件模拟Vue3</strong></p>
<p><strong>main.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">createApp(App).mount(&#x27;#app&#x27;)</span><br><span class="line">👇</span><br><span class="line">createApp(App) + app.mount(&#x27;#app&#x27;)</span><br><span class="line">//创建一个根组件App(Vue应用实例)，然后将其挂载到&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;中，从此这个 &lt;div&gt; 里的内容由 Vue 接管，Vue 会根据 App 的图纸，在&lt;div&gt;中渲染出你写的组件</span><br></pre></td></tr></table></figure>

<p><strong>App.js</strong></p>
<blockquote>
<p><strong>!!! 有关虚拟节点 先去看看这篇文章</strong><a target="_blank" rel="noopener" href="https://juejin.cn/post/7323031996864446505">vue3虚拟dom详解(含源码) - 掘金</a> !!!</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export const App = &#123;</span><br><span class="line">    render() &#123;//UI逻辑</span><br><span class="line">        return h( //Vue 中的创建虚拟 DOM 的辅助函数,用于创建虚拟 DOM 节点,接收三个参数：</span><br><span class="line">            &#x27;div&#x27;, //要创建的 HTML 标签名或组件选项对象.</span><br><span class="line">            &#x27;hi, &#x27; + this.msg //子节点,可以是字符串、数字、数组或其他虚拟 DOM 节点.</span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    setup() &#123;//组合式 API 的入口点,用于组合组件的逻辑，例如响应式数据、生命周期钩子、计算属性等</span><br><span class="line">        return &#123;</span><br><span class="line">            msg: &#x27;mini-vue&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h4><p><strong>createApp.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export function createApp(rootComponent: any) &#123; // 传入根组件</span><br><span class="line">    return &#123;</span><br><span class="line">        mount(rootContainer: any) &#123; // 挂载回根容器</span><br><span class="line">            // 先把根组件转换成虚拟节点vnode</span><br><span class="line">            // 之后所有的操作都会基于vnode做处理</span><br><span class="line">            const vnode = createVNode(rootComponent)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>vnode.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export function createVNode(type: any, props?: any, children?: any) &#123;</span><br><span class="line">    const vnode = &#123;</span><br><span class="line">        type,// 类型</span><br><span class="line">        props,// 属性</span><br><span class="line">        children,// 孩子</span><br><span class="line">        el: null,// 对应的真实dom</span><br><span class="line">        component: null,// 组件实例</span><br><span class="line">        key: props?.key,// 唯一标识</span><br><span class="line">        // shapeFlag: getShapeFlag(type), // 类型标识</span><br><span class="line">    &#125;</span><br><span class="line">    return vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>添加render函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount(rootContainer: any) &#123;</span><br><span class="line">    const vnode = createVNode(rootComponent)</span><br><span class="line"></span><br><span class="line">    render(vnode, rootContainer)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>renderer.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createComponentInstance &#125; from &quot;./component&quot;</span><br><span class="line"></span><br><span class="line">export function render(vnode: any, container: any) &#123;</span><br><span class="line">    // 调用patch函数</span><br><span class="line">    patch(vnode, container)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function patch(vnode: any, container: any) &#123;</span><br><span class="line">    if (vnode.shapeFlag === 1) &#123;</span><br><span class="line">        // 处理element</span><br><span class="line">        processElement(vnode, container)  </span><br><span class="line">    &#125;else if (vnode.shapeFlag === 8) &#123;</span><br><span class="line">        // 处理component</span><br><span class="line">        processComponent(vnode, container)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function processElement(vnode: any, container: any) &#123;</span><br><span class="line">    mountElement(vnode, container)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mountElement(vnode: any, container: any) &#123;</span><br><span class="line">    // 创建组件实例对象</span><br><span class="line">    const instance = createComponentInstance(vnode)</span><br><span class="line"></span><br><span class="line">    // 处理组件的setup</span><br><span class="line">    setupComponent(instance)</span><br><span class="line"></span><br><span class="line">    // 处理组件的render</span><br><span class="line">    setupRenderEffect(instance, vnode, container)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>component.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">export function createComponentInstance(vnode: any) &#123;</span><br><span class="line">    const instance = &#123;</span><br><span class="line">        vnode,          // 组件的虚拟节点（设计图）</span><br><span class="line">        type: vnode.type, // 组件定义（比如你写的 .vue 文件中的对象）</span><br><span class="line">        props: vnode.props, // 外部传入的属性</span><br><span class="line">        slots: vnode.slots, // 插槽内容（类似 `&lt;template #header&gt;`）</span><br><span class="line">        proxy: null,     // 代理对象（用于访问数据和属性）</span><br><span class="line">    &#125;;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function setupComponent(instance: any) &#123;</span><br><span class="line">    // 初始化组件</span><br><span class="line">    initProps(instance)</span><br><span class="line">    initSlots(instance)</span><br><span class="line"></span><br><span class="line">    // 处理组件的setup</span><br><span class="line">    setupStatefulComponent(instance)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function setupStatefulComponent(instance: any) &#123;</span><br><span class="line">    // 先拿到组件</span><br><span class="line">    const Component = instance.type // 组件定义（比如你写的 setup 函数）</span><br><span class="line"></span><br><span class="line">    // 代理对象（用于访问数据和属性）</span><br><span class="line">    instance.proxy = new Proxy(instance, &#123;</span><br><span class="line">        get(target, key) &#123;</span><br><span class="line">            const &#123; setup, props &#125; = target</span><br><span class="line"></span><br><span class="line">            if (key in setup) &#123;// 优先从 setup 返回值中找</span><br><span class="line">                return setup[key]       </span><br><span class="line">            &#125;   else if (key in props) &#123;// 其次从 props 中找</span><br><span class="line">                return props[key]</span><br><span class="line">            &#125;</span><br><span class="line">            return Reflect.get(target, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)  </span><br><span class="line"></span><br><span class="line">    const &#123; setup &#125; = Component //解构出setup</span><br><span class="line"></span><br><span class="line">    if (setup) &#123;</span><br><span class="line">        setCurrentInstance(instance) // 标记“当前对象是谁”</span><br><span class="line">        const setupResult = setup() // 执行你的 setup 函数</span><br><span class="line">        setCurrentInstance(null) // 清除标记</span><br><span class="line"></span><br><span class="line">        handleSetupResult(instance, setupResult) // 保存 setup 返回值</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        finishComponentSetup(instance) // 没有 setup 直接完成初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleSetupResult(instance: any, setupResult: any) &#123;</span><br><span class="line">    if (typeof setupResult === &#x27;object&#x27;) &#123;</span><br><span class="line">        instance.setupState = setupResult; // 保存 setup 返回的对象</span><br><span class="line">    &#125;</span><br><span class="line">    finishComponentSetup(instance); // 完成组装</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function finishComponentSetup(instance: any) &#123;</span><br><span class="line">    const Component = instance.type;</span><br><span class="line">    // 确定 render 函数（你写的 template 会被编译成 render 函数）</span><br><span class="line">    instance.render = Component.render || instance.vnode.render;</span><br><span class="line">    // 准备渲染（虚拟 DOM 生成真实 DOM）</span><br><span class="line">    setupRenderEffect(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>renderer.ts 继续完善逻辑</strong></p>
<blockquote>
<p>**回调render，实现 “拆箱” **</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function setupRenderEffect(instance: any, vnode: any, container: any) &#123;</span><br><span class="line">    const &#123; proxy &#125; = instance</span><br><span class="line">    const subTree = instance.render.call(proxy) //拿到虚拟节点树</span><br><span class="line"></span><br><span class="line">    // vnode -&gt; patch</span><br><span class="line">    // vnode -&gt; element -&gt; mountElement</span><br><span class="line">    patch(subTree, container)</span><br><span class="line"></span><br><span class="line">    vnode.el = subTree.el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-rollup-打包库"><a href="#使用-rollup-打包库" class="headerlink" title="使用 rollup 打包库"></a>使用 rollup 打包库</h3><blockquote>
<p><strong>rollup一般用于库的打包，而webpack更多用于应用的打包</strong></p>
<blockquote>
<p><strong>构建输出的作用👇</strong></p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提供对不同模块格式的支持，增强库的兼容性</span><br><span class="line">优化代码体积与性能</span><br><span class="line">简化库的分发与使用流程，促进组件复用</span><br><span class="line">实现按需加载</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p><strong>在以下案例中就构建了两种格式 CommonJS &amp; ES Module 的文件</strong></p>
</blockquote>
</blockquote>
<h4 id="配置rollup"><a href="#配置rollup" class="headerlink" title="配置rollup"></a>配置rollup</h4><p><strong>安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install --global rollup</span><br></pre></td></tr></table></figure>

<p><strong>安装官方依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pnpm install @rollup/plugin-typescript --save-dev</span><br><span class="line">pnpm install tslib</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>创建 src / index.ts 作为 mini-vue 的出入口</strong></p>
</blockquote>
<p><strong>rollup.config.js 编写脚本文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import typescript from &#x27;@rollup/plugin-typescript&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    input: &#x27;src/index.ts&#x27;, // 入口文件</span><br><span class="line">    output: [</span><br><span class="line">        &#123;</span><br><span class="line">            file: &#x27;lib/guide-mini-vue.cjs.js&#x27;, // 输出的 CommonJS 格式文件</span><br><span class="line">            format: &#x27;cjs&#x27;, // 指定输出格式为 CommonJS</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            file: &#x27;lib/guide-mini-vue.esm.js&#x27;, // 输出的 ES Module 格式文件</span><br><span class="line">            format: &#x27;es&#x27;, // 指定输出格式为 ES Module</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    plugins: [</span><br><span class="line">        // 插件列表</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>构建的输出文件就是lib下的 guide-mini-vue.cjs.js &amp; guide-mini-vue.esm.js 这两个文件</strong></p>
</blockquote>
<p><strong>在package.json中打开依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;jest&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;rollup -c config.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>更改tsconfig.json依赖项</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;module&quot;: &quot;esnext&quot;,</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>处理src下的index文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// mini-vue 的入口</span><br><span class="line">export * from &#x27;./runtime-core&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>再处理runtime-core下的index文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &#123; createApp &#125; from &quot;./createApp&quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>pnpm build 即可构建两种格式的文件</strong></p>
</blockquote>
<p><em><strong>补充h函数逻辑</strong></em></p>
<blockquote>
<p><strong>前情提要</strong></p>
<p><strong>example下的App.js文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export const App = &#123;</span><br><span class="line"> render() &#123; // UI逻辑</span><br><span class="line">     return h( // Vue 中的创建虚拟 DOM 的辅助函数,用于创建虚拟 DOM 节点,接收三个参数：</span><br><span class="line">         &#x27;div&#x27;, // 要创建的 HTML 标签名或组件选项对象.</span><br><span class="line">         &#123;&#125;, // 标签属性,可以是一个对象或数组.</span><br><span class="line">         &#x27;hi, &#x27; + this.msg // 子节点,可以是字符串、数字、数组或其他虚拟 DOM 节点.</span><br><span class="line">     )</span><br><span class="line"> &#125;,</span><br><span class="line"> setup() &#123; // 组合式 API 的入口点,用于组合组件的逻辑，例如响应式数据、生命周期钩子、计算属性等</span><br><span class="line">     return &#123;</span><br><span class="line">         msg: &#x27;mini-vue&#x27;,</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<p><strong>runtime-core / h.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createVNode &#125; from &quot;./vnode&quot;;</span><br><span class="line"></span><br><span class="line">export function h(type: any, props?: any, children?: any) &#123;</span><br><span class="line">    return createVNode(type, props, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>runtime-core / index.ts</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export &#123; createApp &#125; from &#x27;./createApp&#x27;</span><br><span class="line">import &#123; h &#125; from &#x27;./h&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>pnpm build 继续构建到 example 测试项目里</strong></p>
</blockquote>
<p><strong>然后就可以在example中直接引用构建下来的文件</strong></p>
<p><strong>main.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// vue3</span><br><span class="line">import &#123; createApp &#125; from &#x27;../../lib/guide-mini-vue.esm.js&#x27; // 导入自己构建的文件</span><br><span class="line">import &#123; App &#125; from &#x27;./App.js&#x27;</span><br><span class="line"></span><br><span class="line">createApp(App).mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>然后就可以打开HTML文件了</strong></p>
<h2 id="runtime-dom-封装DOM方法"><a href="#runtime-dom-封装DOM方法" class="headerlink" title="runtime-dom 封装DOM方法"></a>runtime-dom 封装DOM方法</h2><h2 id="compiler-core-编译逻辑和算法-1"><a href="#compiler-core-编译逻辑和算法-1" class="headerlink" title="compiler-core 编译逻辑和算法"></a>compiler-core 编译逻辑和算法</h2><h2 id="compiler-sfc-解析-vue组件-1"><a href="#compiler-sfc-解析-vue组件-1" class="headerlink" title="compiler-sfc 解析.vue组件"></a>compiler-sfc 解析.vue组件</h2><h2 id="compiler-dom-处理template标签"><a href="#compiler-dom-处理template标签" class="headerlink" title="compiler-dom 处理template标签"></a>compiler-dom 处理template标签</h2></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="/img/512.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="/img/512.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">Breezli</div><div class="post-copyright__author_desc">“松间听风，忽见灵狸”</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/03/08/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/mini-vue%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/03/08/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/mini-vue%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/')">mini-vue搭建笔记</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/03/08/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/mini-vue%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=mini-vue搭建笔记&amp;url=http://example.com/2025/03/08/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/mini-vue%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/&amp;pic=https://bu.dusays.com/2025/03/05/67c7e99e46b9f.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">松风狸 | Breezli</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2025/03/05/67c7e99e3513a.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/03/08/%E5%B7%A5%E5%85%B7/ECharts%E5%AE%98%E6%96%B9%E5%9B%BE%E8%A1%A8%E5%BA%93CV%E6%95%99%E7%A8%8B/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/05/67c7e99f623e4.webp" onerror="onerror=null;src='https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ECharts图表库实战</div></div></a></div><div class="next-post pull-right"><a href="/2025/03/08/%E5%A4%A7%E5%89%8D%E7%AB%AF/Node.js%E5%9F%BA%E7%A1%80/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/05/67c7e99e5486d.jpg" onerror="onerror=null;src='https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Node.js</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="/img/512.png" onerror="this.onerror=null;this.src='https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="https://emotion.acs.pw/emotion/QQ/129.gif" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">错位的人格，错位的才情；</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">错位的时代，错位的人生。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">在错误的路口抢夺正确的结果，</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">用虚假的手段寻回真实的自己。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">在诗意，自由的“美丽新世界”。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Breezli</h1><div class="author-info__desc">“松间听风，忽见灵狸”</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/Breezli" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/3546391152429457" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(null) center center / 100% no-repeat"></div><div class="back face" style="background: url(null) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#mini-vue%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">mini-vue搭建笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E6%A6%82%E5%86%B5"><span class="toc-number">2.</span> <span class="toc-text">原理概况</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3%E6%A8%A1%E5%9D%97%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">Vue3模块组织方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">2.1.1.</span> <span class="toc-text">流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%9D%A5%E8%AF%B4"><span class="toc-number">2.1.2.</span> <span class="toc-text">简单来说</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%BC%96%E8%AF%91"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">处理编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">处理运行时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E4%B8%BA%E8%AF%A6%E7%BB%86%E7%9A%84"><span class="toc-number">2.1.3.</span> <span class="toc-text">更为详细的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#runtime-reactivity-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">runtime-reactivity 响应式系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runtime-core-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%B8%B2%E6%9F%93"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">runtime-core 跨平台渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runtime-dom-DOM%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">runtime-dom DOM方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compiler-sfc-%E8%A7%A3%E6%9E%90-vue%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">compiler-sfc 解析.vue组件</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/12/JS/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/" title="隐式转换"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/05/67c7e99e3513a.png" onerror="this.onerror=null;this.src='https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif'" alt="隐式转换"/></a><div class="content"><a class="title" href="/2025/05/12/JS/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/" title="隐式转换">隐式转换</a><time datetime="2025-05-11T16:14:38.220Z" title="发表于 2025-05-12 00:14:38">2025-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/12/JS/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="数据类型"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/05/67c7e99e3513a.png" onerror="this.onerror=null;this.src='https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif'" alt="数据类型"/></a><div class="content"><a class="title" href="/2025/05/12/JS/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="数据类型">数据类型</a><time datetime="2025-05-11T16:14:07.985Z" title="发表于 2025-05-12 00:14:07">2025-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/12/JS/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/" title="单点登录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/05/67c7e99e3513a.png" onerror="this.onerror=null;this.src='https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif'" alt="单点登录"/></a><div class="content"><a class="title" href="/2025/05/12/JS/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/" title="单点登录">单点登录</a><time datetime="2025-05-11T16:13:30.112Z" title="发表于 2025-05-12 00:13:30">2025-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/12/JS/%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/" title="原型原型链"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/05/67c7e99e3513a.png" onerror="this.onerror=null;this.src='https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif'" alt="原型原型链"/></a><div class="content"><a class="title" href="/2025/05/12/JS/%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/" title="原型原型链">原型原型链</a><time datetime="2025-05-11T16:11:59.720Z" title="发表于 2025-05-12 00:11:59">2025-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/11/JS/new%E6%93%8D%E4%BD%9C%E7%AC%A6/" title="new操作符"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="https://bu.dusays.com/2025/03/05/67c7e99e3513a.png" onerror="this.onerror=null;this.src='https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif'" alt="new操作符"/></a><div class="content"><a class="title" href="/2025/05/11/JS/new%E6%93%8D%E4%BD%9C%E7%AC%A6/" title="new操作符">new操作符</a><time datetime="2025-05-11T13:27:12.318Z" title="发表于 2025-05-11 21:27:12">2025-05-11</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2025 By <a class="footer-bar-link" href="/" title="Breezli" target="_blank">Breezli</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#footer-type-tips", {
      strings: ["总思念，紫竹萧萧月如钩，溪光摇荡屋如舟","思念那，青山在，绿水流。","-----","花繁一瞬，形色浮云","撇去眼前浮云，方得心之自由。","-----","即使最后归于空寂","过程之间的有情","也同样动容。","-----"],
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("footer-type-tips").innerHTML = '总思念，紫竹萧萧月如钩，溪光摇荡屋如舟'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">9</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://bu.dusays.com/2025/03/05/67c7f047dfa72.gif&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/?id=13242559326&amp;server=netease"><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 梦境</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-plant-fill faa-tada" style="font-size: 0.9em;"></i><span> 簪花人间</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/cinema/"><i class="anzhiyufont anzhiyu-icon-book faa-tada" style="font-size: 0.9em;"></i><span> 匣中秋水</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/gallerygroup/"><i class="anzhiyufont anzhiyu-icon-instagram faa-tada" style="font-size: 0.9em;"></i><span> 彩云霁月</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><span> 友人</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><span> 关于</span></a></div></div><span class="sidebar-menu-item-title">标签</span></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="13242559326" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.5"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=13242559326&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>var meting_api = "https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r";
</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  //- const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  const grt = new Date("2025-3-1");
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);

  const ascll = [
    `   原来我这几十年的岁月，不过只是这样一个简单的故事.`,
    `
                                                                         
██████╗ ██████╗ ███████╗███████╗███████╗██╗     ██╗
██╔══██╗██╔══██╗██╔════╝██╔════╝╚══███╔╝██║     ██║
██████╔╝██████╔╝█████╗  █████╗    ███╔╝ ██║     ██║
██╔══██╗██╔══██╗██╔══╝  ██╔══╝   ███╔╝  ██║     ██║
██████╔╝██║  ██║███████╗███████╗███████╗███████╗██║
╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝╚══════╝╚═╝

    `,
    "   已上线", dnum, "天",
    "©2025 By 松风狸 V1.6.14",
  ];

  setTimeout(
    Log.bind(
      console,
      "%c ⚡ %c 你正在访问 Breezli 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}%c\n`,
      "color:#ffb07c",
      "color:#ffb07c",
      "color:#ffb07c",
      "color:#ffb07c",
      "color:#ffb07c",
      "color:#ffb07c",
      "color:#425AEF"
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好,旅行客。", "color:white; background-color:#4f90d9", ""));
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>